<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawing to Lottie Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            padding: 20px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #222;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        
        .canvas-wrapper {
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 20px;
            background: white;
        }
        
        canvas {
            display: block;
            cursor: crosshair;
            touch-action: none;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button:hover {
            transform: translateY(-1px);
        }
        
        .btn-primary {
            background: #007bff;
            color: white;
        }
        
        .btn-primary:hover {
            background: #0056b3;
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #545b62;
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background: #218838;
        }
        
        .settings {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .setting-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        label {
            font-size: 14px;
            color: #555;
        }
        
        input[type="color"],
        input[type="range"],
        input[type="number"] {
            cursor: pointer;
        }
        
        input[type="range"] {
            width: 120px;
        }
        
        input[type="number"] {
            width: 80px;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .status {
            padding: 12px;
            background: #e7f3ff;
            border-left: 4px solid #007bff;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
            display: none;
        }
        
        .status.active {
            display: block;
        }
        
        .preview {
            margin-top: 30px;
            padding-top: 30px;
            border-top: 2px solid #eee;
        }
        
        .preview h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #222;
        }
        
        .preview-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            min-height: 200px;
            background: #fafafa;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #lottiePreview {
            max-width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Drawing to Lottie Animation</h1>
        <p class="subtitle">Draw with multiple brush types and export as Lottie with Framer Motion springs, custom curves, and loop options. Supports Apple Pencil and drawing tablet pressure.</p>
        
        <div class="settings">
            <div class="setting-group">
                <label>Brush:</label>
                <select id="brushType" style="padding: 6px 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                    <option value="solid">Solid</option>
                    <option value="flow">Flow (Smooth)</option>
                    <option value="marker">Marker</option>
                    <option value="spray">Spray</option>
                    <option value="pencil">Pencil</option>
                    <option value="calligraphy">Calligraphy</option>
                </select>
            </div>
            <div class="setting-group">
                <label>Color:</label>
                <input type="color" id="strokeColor" value="#000000">
                <input type="text" id="hexInput" value="#000000" maxlength="7" style="width: 80px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; text-transform: uppercase;">
            </div>
            <div class="setting-group">
                <label>Width:</label>
                <input type="range" id="strokeWidth" min="1" max="20" value="3">
                <span id="widthValue">3px</span>
            </div>
            <div class="setting-group">
                <label>Speed:</label>
                <input type="number" id="animationSpeed" min="0.1" max="5" step="0.1" value="1">
                <span>x</span>
            </div>
            <div class="setting-group">
                <label>Pressure:</label>
                <span id="pressureValue" style="font-weight: 500; color: #007bff;">0%</span>
            </div>
            <div class="setting-group">
                <input type="checkbox" id="pencilOnlyMode" style="cursor: pointer;">
                <label for="pencilOnlyMode" style="cursor: pointer;">Apple Pencil Only</label>
            </div>
            <div class="setting-group">
                <input type="checkbox" id="pressureSensitivity" checked style="cursor: pointer;">
                <label for="pressureSensitivity" style="cursor: pointer;">Pressure Sensitivity</label>
            </div>
            <div class="setting-group">
                <label>Smoothing:</label>
                <input type="range" id="smoothingStrength" min="0" max="100" value="50" style="width: 120px;">
                <span id="smoothingValue">50%</span>
                <button onclick="applySmoothingToAllStrokes()" class="btn-secondary" style="padding: 6px 12px; font-size: 13px;">Apply</button>
            </div>
        </div>
        
        <div class="settings">
            <div class="setting-group">
                <label>Easing:</label>
                <select id="easingType" style="padding: 6px 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                    <optgroup label="Standard">
                        <option value="linear">Linear</option>
                        <option value="easeIn">Ease In</option>
                        <option value="easeOut">Ease Out</option>
                        <option value="easeInOut">Ease In-Out</option>
                        <option value="anticipate">Anticipate</option>
                        <option value="overshoot">Overshoot</option>
                    </optgroup>
                    <optgroup label="Framer Motion">
                        <option value="spring">Spring (Default)</option>
                        <option value="springBouncy">Spring (Bouncy)</option>
                        <option value="springSnappy">Spring (Snappy)</option>
                        <option value="springGentle">Spring (Gentle)</option>
                        <option value="springWobbly">Spring (Wobbly)</option>
                    </optgroup>
                    <option value="custom">Custom Curve</option>
                </select>
            </div>
            <div class="setting-group">
                <canvas id="easingPreview" width="150" height="40" style="border: 1px solid #ddd; border-radius: 4px; background: #fafafa;"></canvas>
            </div>
            <div class="setting-group">
                <label>Loop:</label>
                <select id="loopType" style="padding: 6px 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                    <option value="once">Play Once</option>
                    <option value="loop">Loop Forward</option>
                    <option value="reverse">Loop Reverse</option>
                    <option value="pingpong">Ping Pong</option>
                </select>
            </div>
        </div>
        
        <div class="settings" id="customCurveControls" style="display: none;">
            <div class="setting-group">
                <label>Custom Bezier Curve:</label>
            </div>
            <div class="setting-group">
                <label>X1:</label>
                <input type="number" id="curveX1" min="0" max="1" step="0.01" value="0.42">
            </div>
            <div class="setting-group">
                <label>Y1:</label>
                <input type="number" id="curveY1" min="-2" max="2" step="0.01" value="0">
            </div>
            <div class="setting-group">
                <label>X2:</label>
                <input type="number" id="curveX2" min="0" max="1" step="0.01" value="0.58">
            </div>
            <div class="setting-group">
                <label>Y2:</label>
                <input type="number" id="curveY2" min="-2" max="2" step="0.01" value="1">
            </div>
            <div class="setting-group">
                <canvas id="curvePreview" width="100" height="100" style="border: 1px solid #ddd; border-radius: 4px;"></canvas>
            </div>
        </div>
        
        <div class="settings" id="curvePresets" style="display: none; gap: 5px;">
            <div class="setting-group">
                <label>Presets:</label>
            </div>
            <button class="btn-secondary" style="padding: 6px 12px; font-size: 12px;" onclick="setCurve(0.42, 0, 1, 1)">Ease In</button>
            <button class="btn-secondary" style="padding: 6px 12px; font-size: 12px;" onclick="setCurve(0, 0, 0.58, 1)">Ease Out</button>
            <button class="btn-secondary" style="padding: 6px 12px; font-size: 12px;" onclick="setCurve(0.42, 0, 0.58, 1)">Ease In-Out</button>
            <button class="btn-secondary" style="padding: 6px 12px; font-size: 12px;" onclick="setCurve(0.68, -0.55, 0.265, 1.55)">Back</button>
            <button class="btn-secondary" style="padding: 6px 12px; font-size: 12px;" onclick="setCurve(0.175, 0.885, 0.32, 1.275)">Elastic</button>
        </div>
        
        <div class="canvas-wrapper">
            <canvas id="drawingCanvas" width="800" height="500"></canvas>
        </div>
        
        <div class="controls">
            <button class="btn-primary" id="clearBtn">Clear Canvas</button>
            <button class="btn-secondary" id="undoBtn">Undo</button>
            <button class="btn-secondary" id="redoBtn">Redo</button>
            <button class="btn-secondary" id="replayBtn">Replay Drawing</button>
            <button class="btn-secondary" id="previewAnimBtn">Preview Lottie</button>
            <button class="btn-success" id="exportBtn">Export Lottie JSON</button>
        </div>
        
        <div class="status" id="status"></div>
        
        <div class="preview">
            <h2>Preview Animation</h2>
            <div class="preview-area" id="previewArea">
                <p style="color: #999; text-align: center;">Your animation will appear here after export</p>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const brushTypeInput = document.getElementById('brushType');
        const strokeColorInput = document.getElementById('strokeColor');
        const hexInput = document.getElementById('hexInput');
        const strokeWidthInput = document.getElementById('strokeWidth');
        const widthValueSpan = document.getElementById('widthValue');
        const animationSpeedInput = document.getElementById('animationSpeed');
        const pressureValueSpan = document.getElementById('pressureValue');
        const pencilOnlyMode = document.getElementById('pencilOnlyMode');
        const pressureSensitivity = document.getElementById('pressureSensitivity');
        const smoothingStrength = document.getElementById('smoothingStrength');
        const smoothingValue = document.getElementById('smoothingValue');
        const easingTypeInput = document.getElementById('easingType');
        const loopTypeInput = document.getElementById('loopType');
        const customCurveControls = document.getElementById('customCurveControls');
        const curveX1Input = document.getElementById('curveX1');
        const curveY1Input = document.getElementById('curveY1');
        const curveX2Input = document.getElementById('curveX2');
        const curveY2Input = document.getElementById('curveY2');
        const curvePreviewCanvas = document.getElementById('curvePreview');
        const curvePreviewCtx = curvePreviewCanvas.getContext('2d');
        const easingPreviewCanvas = document.getElementById('easingPreview');
        const easingPreviewCtx = easingPreviewCanvas.getContext('2d');
        const curvePresets = document.getElementById('curvePresets');
        const clearBtn = document.getElementById('clearBtn');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const replayBtn = document.getElementById('replayBtn');
        const previewAnimBtn = document.getElementById('previewAnimBtn');
        const exportBtn = document.getElementById('exportBtn');
        const status = document.getElementById('status');
        const previewArea = document.getElementById('previewArea');
        
        let isDrawing = false;
        let strokes = [];
        let redoStack = [];
        let currentStroke = [];
        let startTime = 0;
        let lottieInstance = null;
        let easingAnimationFrame = null;
        
        // Function to set curve values
        function setCurve(x1, y1, x2, y2) {
            curveX1Input.value = x1;
            curveY1Input.value = y1;
            curveX2Input.value = x2;
            curveY2Input.value = y2;
            drawCurvePreview();
            animateEasingPreview();
        }
        
        // Make setCurve globally accessible for onclick handlers
        window.setCurve = setCurve;
        
        // Cubic bezier easing function
        function cubicBezier(t, p1x, p1y, p2x, p2y) {
            const cx = 3 * p1x;
            const bx = 3 * (p2x - p1x) - cx;
            const ax = 1 - cx - bx;
            const cy = 3 * p1y;
            const by = 3 * (p2y - p1y) - cy;
            const ay = 1 - cy - by;
            
            function sampleCurveX(t) {
                return ((ax * t + bx) * t + cx) * t;
            }
            
            function sampleCurveY(t) {
                return ((ay * t + by) * t + cy) * t;
            }
            
            function solveCurveX(x) {
                let t2 = x;
                for (let i = 0; i < 8; i++) {
                    const x2 = sampleCurveX(t2) - x;
                    if (Math.abs(x2) < 0.000001) return t2;
                    const d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                    if (Math.abs(d2) < 0.000001) break;
                    t2 = t2 - x2 / d2;
                }
                return t2;
            }
            
            return sampleCurveY(solveCurveX(t));
        }
        
        // Animate easing preview
        function animateEasingPreview() {
            if (easingAnimationFrame) {
                cancelAnimationFrame(easingAnimationFrame);
            }
            
            const width = easingPreviewCanvas.width;
            const height = easingPreviewCanvas.height;
            const ballRadius = 6;
            const startX = ballRadius + 5;
            const endX = width - ballRadius - 5;
            const y = height / 2;
            
            const duration = 1500; // 1.5 seconds
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Get easing values
                const easingType = easingTypeInput.value;
                const easing = getEasingValues(easingType);
                
                // Apply easing
                const easedProgress = cubicBezier(progress, easing.i.x[0], easing.i.y[0], easing.o.x[0], easing.o.y[0]);
                const x = startX + (endX - startX) * easedProgress;
                
                // Clear and draw
                easingPreviewCtx.clearRect(0, 0, width, height);
                
                // Draw track
                easingPreviewCtx.strokeStyle = '#ddd';
                easingPreviewCtx.lineWidth = 2;
                easingPreviewCtx.beginPath();
                easingPreviewCtx.moveTo(startX, y);
                easingPreviewCtx.lineTo(endX, y);
                easingPreviewCtx.stroke();
                
                // Draw ball
                easingPreviewCtx.fillStyle = '#007bff';
                easingPreviewCtx.beginPath();
                easingPreviewCtx.arc(x, y, ballRadius, 0, Math.PI * 2);
                easingPreviewCtx.fill();
                
                if (progress < 1) {
                    easingAnimationFrame = requestAnimationFrame(animate);
                } else {
                    // Loop the animation
                    setTimeout(() => animateEasingPreview(), 300);
                }
            }
            
            animate();
        }
        
        // Show/hide custom curve controls
        easingTypeInput.addEventListener('change', (e) => {
            if (e.target.value === 'custom') {
                customCurveControls.style.display = 'flex';
                curvePresets.style.display = 'flex';
                drawCurvePreview();
            } else {
                customCurveControls.style.display = 'none';
                curvePresets.style.display = 'none';
            }
            animateEasingPreview();
        });
        
        // Start easing preview on load
        setTimeout(() => animateEasingPreview(), 100);
        
        // Sync color picker and hex input
        strokeColorInput.addEventListener('input', (e) => {
            hexInput.value = e.target.value.toUpperCase();
        });
        
        hexInput.addEventListener('input', (e) => {
            let hex = e.target.value.trim();
            
            // Auto-add # if missing
            if (hex.length > 0 && !hex.startsWith('#')) {
                hex = '#' + hex;
                hexInput.value = hex;
            }
            
            // Validate hex format
            if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                strokeColorInput.value = hex;
            }
        });
        
        hexInput.addEventListener('blur', (e) => {
            // Ensure valid format on blur
            let hex = e.target.value.trim();
            if (!hex.startsWith('#')) {
                hex = '#' + hex;
            }
            
            // If not valid, reset to current color
            if (!/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                hexInput.value = strokeColorInput.value.toUpperCase();
            } else {
                hexInput.value = hex.toUpperCase();
                strokeColorInput.value = hex;
            }
        });
        
        // Update curve preview when values change
        curveX1Input.addEventListener('input', () => {
            drawCurvePreview();
            animateEasingPreview();
        });
        curveY1Input.addEventListener('input', () => {
            drawCurvePreview();
            animateEasingPreview();
        });
        curveX2Input.addEventListener('input', () => {
            drawCurvePreview();
            animateEasingPreview();
        });
        curveY2Input.addEventListener('input', () => {
            drawCurvePreview();
            animateEasingPreview();
        });
        
        function drawCurvePreview() {
            const x1 = parseFloat(curveX1Input.value);
            const y1 = parseFloat(curveY1Input.value);
            const x2 = parseFloat(curveX2Input.value);
            const y2 = parseFloat(curveY2Input.value);
            
            const width = curvePreviewCanvas.width;
            const height = curvePreviewCanvas.height;
            const padding = 10;
            
            curvePreviewCtx.clearRect(0, 0, width, height);
            
            // Draw grid
            curvePreviewCtx.strokeStyle = '#eee';
            curvePreviewCtx.lineWidth = 1;
            curvePreviewCtx.beginPath();
            curvePreviewCtx.moveTo(padding, padding);
            curvePreviewCtx.lineTo(padding, height - padding);
            curvePreviewCtx.lineTo(width - padding, height - padding);
            curvePreviewCtx.stroke();
            
            // Draw bezier curve
            curvePreviewCtx.strokeStyle = '#007bff';
            curvePreviewCtx.lineWidth = 2;
            curvePreviewCtx.beginPath();
            
            const startX = padding;
            const startY = height - padding;
            const endX = width - padding;
            const endY = padding;
            
            const cp1X = startX + (endX - startX) * x1;
            const cp1Y = startY - (startY - endY) * y1;
            const cp2X = startX + (endX - startX) * x2;
            const cp2Y = startY - (startY - endY) * y2;
            
            curvePreviewCtx.moveTo(startX, startY);
            curvePreviewCtx.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, endX, endY);
            curvePreviewCtx.stroke();
            
            // Draw control points
            curvePreviewCtx.fillStyle = '#007bff';
            curvePreviewCtx.beginPath();
            curvePreviewCtx.arc(cp1X, cp1Y, 3, 0, Math.PI * 2);
            curvePreviewCtx.arc(cp2X, cp2Y, 3, 0, Math.PI * 2);
            curvePreviewCtx.fill();
        }
        
        // Update width display
        strokeWidthInput.addEventListener('input', (e) => {
            widthValueSpan.textContent = e.target.value + 'px';
        });
        
        smoothingStrength.addEventListener('input', (e) => {
            smoothingValue.textContent = e.target.value + '%';
        });
        
        // Pointer events (supports mouse, touch, and stylus with pressure)
        canvas.addEventListener('pointerdown', startDrawing);
        canvas.addEventListener('pointermove', draw);
        canvas.addEventListener('pointerup', stopDrawing);
        canvas.addEventListener('pointerleave', stopDrawing);
        canvas.addEventListener('pointercancel', stopDrawing);
        
        function getPointerPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const rawPressure = e.pressure || 0.5;
            // If pressure sensitivity is off, use maximum pressure (1.0)
            const pressure = pressureSensitivity.checked ? rawPressure : 1.0;
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top,
                pressure: pressure
            };
        }
        
        function startDrawing(e) {
            // Check if pencil only mode is enabled
            if (pencilOnlyMode.checked && e.pointerType !== 'pen') {
                return; // Ignore touch and mouse input when pencil only mode is on
            }
            
            e.preventDefault();
            isDrawing = true;
            if (strokes.length === 0) {
                startTime = Date.now();
            }
            
            const pos = getPointerPosition(e);
            const baseWidth = parseInt(strokeWidthInput.value);
            
            // Update pressure display
            pressureValueSpan.textContent = Math.round(pos.pressure * 100) + '%';
            
            currentStroke = {
                points: [],
                color: strokeColorInput.value,
                baseWidth: baseWidth,
                brushType: brushTypeInput.value,
                startTime: Date.now() - startTime
            };
            
            currentStroke.points.push({
                x: pos.x,
                y: pos.y,
                pressure: pos.pressure,
                time: Date.now() - startTime
            });
        }
        
        function draw(e) {
            if (!isDrawing) return;
            
            if (pencilOnlyMode.checked && e.pointerType !== 'pen') {
                return;
            }
            
            e.preventDefault();
            
            const pos = getPointerPosition(e);
            const point = {
                x: pos.x,
                y: pos.y,
                pressure: pos.pressure,
                time: Date.now() - startTime
            };
            
            pressureValueSpan.textContent = Math.round(pos.pressure * 100) + '%';
            currentStroke.points.push(point);
            
            const len = currentStroke.points.length;
            if (len < 2) return;
            
            const brushType = currentStroke.brushType;
            
            ctx.strokeStyle = currentStroke.color;
            ctx.fillStyle = currentStroke.color;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            if (brushType === 'marker') {
                ctx.globalAlpha = 0.6;
            } else if (brushType === 'pencil') {
                ctx.globalAlpha = 0.7;
            } else {
                ctx.globalAlpha = 1.0;
            }
            
            const p1 = currentStroke.points[len - 2];
            const p2 = currentStroke.points[len - 1];
            
            const avgPressure = (p1.pressure + p2.pressure) / 2;
            const lineWidth = currentStroke.baseWidth * avgPressure;
            ctx.lineWidth = lineWidth;
            
            if (len === 2) {
                // First segment - just a line
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            } else {
                // Draw smooth quadratic curve
                const p0 = currentStroke.points[len - 3];
                
                // Midpoint between p0 and p1 is our start
                const startX = (p0.x + p1.x) / 2;
                const startY = (p0.y + p1.y) / 2;
                
                // Midpoint between p1 and p2 is our end
                const endX = (p1.x + p2.x) / 2;
                const endY = (p1.y + p2.y) / 2;
                
                // p1 is our control point
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.quadraticCurveTo(p1.x, p1.y, endX, endY);
                ctx.stroke();
                
                if (brushType === 'pencil') {
                    for (let i = 0; i < 2; i++) {
                        const offset = (Math.random() - 0.5) * lineWidth * 0.5;
                        ctx.lineWidth = 0.5;
                        ctx.globalAlpha = Math.random() * 0.3;
                        ctx.beginPath();
                        ctx.moveTo(startX + offset, startY + offset);
                        ctx.quadraticCurveTo(p1.x + offset, p1.y + offset, endX + offset, endY + offset);
                        ctx.stroke();
                        ctx.lineWidth = lineWidth;
                    }
                }
            }
            
            ctx.globalAlpha = 1.0;
        }
        
        function stopDrawing(e) {
            if (!isDrawing) return;
            if (e) e.preventDefault();
            isDrawing = false;
            pressureValueSpan.textContent = '0%';
            if (currentStroke.points.length > 0) {
                strokes.push(currentStroke);
                redoStack = []; // Clear redo history when new stroke is added
            }
        }
        
        // Clear canvas
        clearBtn.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            strokes = [];
            redoStack = [];
            startTime = 0;
            pressureValueSpan.textContent = '0%';
            showStatus('Canvas cleared');
        });
        
        // Redraw canvas from strokes
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            strokes.forEach(stroke => {
                const brushType = stroke.brushType;
                
                ctx.strokeStyle = stroke.color;
                ctx.fillStyle = stroke.color;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                if (brushType === 'marker') {
                    ctx.globalAlpha = 0.6;
                } else if (brushType === 'pencil') {
                    ctx.globalAlpha = 0.7;
                } else {
                    ctx.globalAlpha = 1.0;
                }
                
                for (let i = 1; i < stroke.points.length; i++) {
                    const p1 = stroke.points[i - 1];
                    const p2 = stroke.points[i];
                    
                    const avgPressure = (p1.pressure + p2.pressure) / 2;
                    const lineWidth = stroke.baseWidth * avgPressure;
                    ctx.lineWidth = lineWidth;
                    
                    if (i === 1) {
                        // First segment
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    } else {
                        // Smooth curve
                        const p0 = stroke.points[i - 2];
                        
                        const startX = (p0.x + p1.x) / 2;
                        const startY = (p0.y + p1.y) / 2;
                        const endX = (p1.x + p2.x) / 2;
                        const endY = (p1.y + p2.y) / 2;
                        
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.quadraticCurveTo(p1.x, p1.y, endX, endY);
                        ctx.stroke();
                        
                        if (brushType === 'pencil') {
                            for (let j = 0; j < 2; j++) {
                                const offset = (Math.random() - 0.5) * lineWidth * 0.5;
                                ctx.lineWidth = 0.5;
                                ctx.globalAlpha = Math.random() * 0.3;
                                ctx.beginPath();
                                ctx.moveTo(startX + offset, startY + offset);
                                ctx.quadraticCurveTo(p1.x + offset, p1.y + offset, endX + offset, endY + offset);
                                ctx.stroke();
                                ctx.lineWidth = lineWidth;
                            }
                        }
                    }
                }
                
                ctx.globalAlpha = 1.0;
            });
        }
        
        // Smooth stroke points using simplified path algorithm
        function smoothStroke(points, strength) {
            if (points.length < 3) return points;
            
            // Strength: 0 = no smoothing (keep all points), 100 = maximum smoothing (very few points)
            // Convert to epsilon for Douglas-Peucker algorithm
            const minPoints = 5;
            const maxPoints = points.length;
            const targetPoints = Math.max(minPoints, Math.floor(maxPoints * (1 - strength / 100)));
            
            // Simple downsampling for smoothing
            if (targetPoints >= points.length) return points;
            
            const step = points.length / targetPoints;
            const smoothed = [];
            
            // Always keep first point
            smoothed.push(points[0]);
            
            // Sample points evenly
            for (let i = 1; i < targetPoints - 1; i++) {
                const idx = Math.floor(i * step);
                smoothed.push(points[idx]);
            }
            
            // Always keep last point
            smoothed.push(points[points.length - 1]);
            
            return smoothed;
        }
        
        // Apply smoothing to all strokes
        function applySmoothingToAllStrokes() {
            const strength = parseInt(smoothingStrength.value);
            
            if (strokes.length === 0) {
                alert('No strokes to smooth!');
                return;
            }
            
            // Apply smoothing to each stroke
            strokes.forEach(stroke => {
                stroke.points = smoothStroke(stroke.points, strength);
            });
            
            // Redraw canvas with smoothed strokes
            redrawCanvas();
            
            // Show feedback
            console.log(`Applied ${strength}% smoothing to ${strokes.length} strokes`);
        }
        
        // Undo
        undoBtn.addEventListener('click', () => {
            if (strokes.length === 0) {
                showStatus('Nothing to undo');
                return;
            }
            
            const lastStroke = strokes.pop();
            redoStack.push(lastStroke);
            redrawCanvas();
            showStatus('Undo successful');
        });
        
        // Redo
        redoBtn.addEventListener('click', () => {
            if (redoStack.length === 0) {
                showStatus('Nothing to redo');
                return;
            }
            
            const strokeToRestore = redoStack.pop();
            strokes.push(strokeToRestore);
            redrawCanvas();
            showStatus('Redo successful');
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl+Z or Cmd+Z for undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undoBtn.click();
            }
            // Ctrl+Y or Cmd+Y or Ctrl+Shift+Z for redo
            else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.shiftKey && e.key === 'z'))) {
                e.preventDefault();
                redoBtn.click();
            }
        });
        
        // Touch gestures for iPad (two-finger tap = undo, three-finger tap = redo)
        let touchStartTime = 0;
        let touchCount = 0;
        const tapTimeout = 300; // Maximum time for a tap in milliseconds
        
        canvas.addEventListener('touchstart', (e) => {
            touchCount = e.touches.length;
            touchStartTime = Date.now();
        }, { passive: true });
        
        canvas.addEventListener('touchend', (e) => {
            const touchDuration = Date.now() - touchStartTime;
            
            // Only trigger if it was a quick tap (not a drag)
            if (touchDuration < tapTimeout) {
                // Two-finger tap for undo
                if (touchCount === 2) {
                    e.preventDefault();
                    undoBtn.click();
                }
                // Three-finger tap for redo
                else if (touchCount === 3) {
                    e.preventDefault();
                    redoBtn.click();
                }
            }
        });
        
        // Replay animation
        replayBtn.addEventListener('click', () => {
            if (strokes.length === 0) {
                showStatus('Nothing to replay. Draw something first.');
                return;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            showStatus('Replaying animation...');
            
            const speed = parseFloat(animationSpeedInput.value);
            let strokeIndex = 0;
            let pointIndex = 0;
            
            function animate() {
                if (strokeIndex >= strokes.length) {
                    showStatus('Replay complete');
                    return;
                }
                
                const stroke = strokes[strokeIndex];
                
                if (pointIndex < stroke.points.length) {
                    if (pointIndex > 0) {
                        const prevPoint = stroke.points[pointIndex - 1];
                        const currPoint = stroke.points[pointIndex];
                        const avgPressure = (prevPoint.pressure + currPoint.pressure) / 2;
                        const lineWidth = stroke.baseWidth * avgPressure;
                        
                        ctx.strokeStyle = stroke.color;
                        ctx.fillStyle = stroke.color;
                        ctx.lineJoin = 'round';
                        
                        const brushType = stroke.brushType;
                        
                        if (brushType === 'solid') {
                            ctx.lineWidth = lineWidth;
                            ctx.lineCap = 'round';
                            ctx.beginPath();
                            ctx.moveTo(prevPoint.x, prevPoint.y);
                            ctx.lineTo(currPoint.x, currPoint.y);
                            ctx.stroke();
                        } else if (brushType === 'flow') {
                            ctx.lineWidth = lineWidth;
                            ctx.lineCap = 'round';
                            
                            if (pointIndex > 1) {
                                const prevPrevPoint = stroke.points[pointIndex - 2];
                                const midX = (prevPrevPoint.x + prevPoint.x) / 2;
                                const midY = (prevPrevPoint.y + prevPoint.y) / 2;
                                const midX2 = (prevPoint.x + currPoint.x) / 2;
                                const midY2 = (prevPoint.y + currPoint.y) / 2;
                                
                                ctx.beginPath();
                                ctx.moveTo(midX, midY);
                                ctx.quadraticCurveTo(prevPoint.x, prevPoint.y, midX2, midY2);
                                ctx.stroke();
                            } else {
                                ctx.beginPath();
                                ctx.moveTo(prevPoint.x, prevPoint.y);
                                ctx.lineTo(currPoint.x, currPoint.y);
                                ctx.stroke();
                            }
                        } else if (brushType === 'marker') {
                            ctx.lineWidth = lineWidth;
                            ctx.lineCap = 'butt';
                            ctx.globalAlpha = 0.6;
                            ctx.beginPath();
                            ctx.moveTo(prevPoint.x, prevPoint.y);
                            ctx.lineTo(currPoint.x, currPoint.y);
                            ctx.stroke();
                            ctx.globalAlpha = 1.0;
                        } else if (brushType === 'spray') {
                            const distance = Math.sqrt(Math.pow(currPoint.x - prevPoint.x, 2) + Math.pow(currPoint.y - prevPoint.y, 2));
                            const density = Math.max(1, Math.floor(distance / 2));
                            
                            for (let i = 0; i < density; i++) {
                                const t = i / density;
                                const x = prevPoint.x + (currPoint.x - prevPoint.x) * t;
                                const y = prevPoint.y + (currPoint.y - prevPoint.y) * t;
                                
                                const sprayRadius = lineWidth * 2;
                                const offsetX = (Math.random() - 0.5) * sprayRadius;
                                const offsetY = (Math.random() - 0.5) * sprayRadius;
                                
                                ctx.globalAlpha = Math.random() * 0.5 + 0.3;
                                ctx.beginPath();
                                ctx.arc(x + offsetX, y + offsetY, Math.random() * 1.5, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            ctx.globalAlpha = 1.0;
                        } else if (brushType === 'pencil') {
                            ctx.lineWidth = lineWidth;
                            ctx.lineCap = 'butt';
                            ctx.globalAlpha = 0.7;
                            ctx.beginPath();
                            ctx.moveTo(prevPoint.x, prevPoint.y);
                            ctx.lineTo(currPoint.x, currPoint.y);
                            ctx.stroke();
                            
                            for (let i = 0; i < 3; i++) {
                                const offset = (Math.random() - 0.5) * lineWidth * 0.5;
                                ctx.lineWidth = 0.5;
                                ctx.globalAlpha = Math.random() * 0.3;
                                ctx.beginPath();
                                ctx.moveTo(prevPoint.x + offset, prevPoint.y + offset);
                                ctx.lineTo(currPoint.x + offset, currPoint.y + offset);
                                ctx.stroke();
                            }
                            ctx.globalAlpha = 1.0;
                        } else if (brushType === 'calligraphy') {
                            const angle = Math.atan2(currPoint.y - prevPoint.y, currPoint.x - prevPoint.x);
                            const calligraphyAngle = Math.PI / 4;
                            const widthMultiplier = Math.abs(Math.cos(angle - calligraphyAngle)) * 0.7 + 0.3;
                            
                            ctx.lineWidth = lineWidth * widthMultiplier;
                            ctx.lineCap = 'butt';
                            ctx.beginPath();
                            ctx.moveTo(prevPoint.x, prevPoint.y);
                            ctx.lineTo(currPoint.x, currPoint.y);
                            ctx.stroke();
                        }
                    }
                    
                    pointIndex++;
                    
                    if (pointIndex < stroke.points.length) {
                        const delay = (stroke.points[pointIndex].time - stroke.points[pointIndex - 1].time) / speed;
                        setTimeout(animate, delay);
                    } else {
                        strokeIndex++;
                        pointIndex = 0;
                        setTimeout(animate, 10 / speed); // Minimal delay between strokes
                    }
                }
            }
            
            animate();
        });
        
        // Preview Lottie animation
        previewAnimBtn.addEventListener('click', () => {
            if (strokes.length === 0) {
                showStatus('Nothing to preview. Draw something first.');
                return;
            }
            
            const lottieData = generateLottieJSON();
            showPreview(lottieData);
            showStatus('Preview loaded successfully!');
        });
        
        // Export to Lottie
        exportBtn.addEventListener('click', () => {
            if (strokes.length === 0) {
                showStatus('Nothing to export. Draw something first.');
                return;
            }
            
            const lottieData = generateLottieJSON();
            downloadLottie(lottieData);
            showPreview(lottieData);
            showStatus('Lottie JSON exported successfully!');
        });
        
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16) / 255,
                g: parseInt(result[2], 16) / 255,
                b: parseInt(result[3], 16) / 255
            } : { r: 0, g: 0, b: 0 };
        }
        
        function getEasingValues(easingType) {
            // Custom curve
            if (easingType === 'custom') {
                const x1 = parseFloat(curveX1Input.value);
                const y1 = parseFloat(curveY1Input.value);
                const x2 = parseFloat(curveX2Input.value);
                const y2 = parseFloat(curveY2Input.value);
                return { i: { x: [x1], y: [y1] }, o: { x: [x2], y: [y2] } };
            }
            
            const easings = {
                // Standard easings
                linear: { i: { x: [0], y: [0] }, o: { x: [1], y: [1] } },
                easeIn: { i: { x: [0.42], y: [0] }, o: { x: [1], y: [1] } },
                easeOut: { i: { x: [0], y: [0] }, o: { x: [0.58], y: [1] } },
                easeInOut: { i: { x: [0.42], y: [0] }, o: { x: [0.58], y: [1] } },
                anticipate: { i: { x: [0.36], y: [0] }, o: { x: [0.66], y: [-0.56] } },
                overshoot: { i: { x: [0.34], y: [1.56] }, o: { x: [0.64], y: [1] } },
                
                // Framer Motion spring animations (better approximations)
                // True springs need physics, but these bezier curves feel spring-like
                spring: { i: { x: [0.16], y: [1] }, o: { x: [0.3], y: [1] } }, // Default spring
                springBouncy: { i: { x: [0.68], y: [-0.6] }, o: { x: [0.32], y: [1.6] } }, // More bounce
                springSnappy: { i: { x: [0.34], y: [1.56] }, o: { x: [0.64], y: [1] } }, // Quick settle
                springGentle: { i: { x: [0.25], y: [0.1] }, o: { x: [0.25], y: [1] } }, // Soft and smooth
                springWobbly: { i: { x: [0.8], y: [-0.9] }, o: { x: [0.2], y: [1.9] } } // Max overshoot
            };
            return easings[easingType] || easings.linear;
        }
        
        function generateLottieJSON() {
            const speed = parseFloat(animationSpeedInput.value);
            const fps = 60;
            const easingType = easingTypeInput.value;
            const loopType = loopTypeInput.value;
            
            // Calculate total duration
            let maxTime = 0;
            strokes.forEach(stroke => {
                const lastPoint = stroke.points[stroke.points.length - 1];
                if (lastPoint.time > maxTime) {
                    maxTime = lastPoint.time;
                }
            });
            
            const totalDuration = (maxTime / 1000 / speed) * fps;
            
            // Handle different loop types
            let loopValue = true;
            let direction = 1;
            
            if (loopType === 'once') {
                loopValue = false;
            } else if (loopType === 'reverse') {
                loopValue = true;
                direction = -1;
            } else if (loopType === 'pingpong') {
                loopValue = 2;
            }
            
            const lottieJSON = {
                v: "5.7.4",
                fr: fps,
                ip: 0,
                op: totalDuration + 30,
                w: canvas.width,
                h: canvas.height,
                nm: "Drawing Animation",
                ddd: 0,
                assets: [],
                layers: [],
                markers: []
            };
            
            lottieJSON.meta = {
                loop: loopValue,
                direction: direction
            };
            
            // Create segments with pressure sensitivity
            let layerIndex = 0;
            
            strokes.forEach((stroke, strokeIdx) => {
                const rgb = hexToRgb(stroke.color);
                const easing = getEasingValues(easingType);
                
                // Keep all points to preserve pressure sensitivity
                // Native iPad apps don't simplify - they use all the data
                const simplifiedPoints = stroke.points;
                
                // Use larger segments with less overlap for smoother appearance
                const segmentSize = 12; // Larger segments = smoother curves
                const stepSize = 6; // 50% overlap
                
                for (let i = 0; i < simplifiedPoints.length - 1; i += stepSize) {
                    const endIdx = Math.min(i + segmentSize, simplifiedPoints.length);
                    const segmentPoints = simplifiedPoints.slice(i, endIdx);
                    
                    if (segmentPoints.length < 2) continue;
                    
                    // Average pressure for segment
                    const avgPressure = segmentPoints.reduce((sum, p) => sum + p.pressure, 0) / segmentPoints.length;
                    const segmentWidth = stroke.baseWidth * avgPressure;
                    
                    // Create smooth bezier path
                    const bezierPath = createSmoothBezierPath(segmentPoints);
                    
                    const startTime = segmentPoints[0].time;
                    const endTime = segmentPoints[segmentPoints.length - 1].time;
                    const startFrame = (startTime / 1000 / speed) * fps;
                    const endFrame = (endTime / 1000 / speed) * fps;
                    
                    // Line cap
                    let lineCap = 2; // round
                    if (stroke.brushType === 'marker' || stroke.brushType === 'pencil' || stroke.brushType === 'calligraphy') {
                        lineCap = 1;
                    }
                    
                    // Opacity
                    let opacity = 100;
                    if (stroke.brushType === 'marker') {
                        opacity = 60;
                    } else if (stroke.brushType === 'pencil') {
                        opacity = 70;
                    }
                    
                    const layer = {
                        ddd: 0,
                        ind: layerIndex + 1,
                        ty: 4,
                        nm: `Stroke ${strokeIdx + 1} Seg ${Math.floor(i / stepSize)}`,
                        sr: 1,
                        ks: {
                            o: { a: 0, k: opacity, ix: 11 },
                            r: { a: 0, k: 0, ix: 10 },
                            p: { a: 0, k: [0, 0, 0], ix: 2 },
                            a: { a: 0, k: [0, 0, 0], ix: 1 },
                            s: { a: 0, k: [100, 100, 100], ix: 6 }
                        },
                        ao: 0,
                        shapes: [
                            {
                                ty: "gr",
                                it: [
                                    {
                                        ind: 0,
                                        ty: "sh",
                                        ix: 1,
                                        ks: {
                                            a: 0,
                                            k: bezierPath,
                                            ix: 2
                                        },
                                        nm: "Path 1",
                                        mn: "ADBE Vector Shape - Group",
                                        hd: false
                                    },
                                    {
                                        ty: "st",
                                        c: {
                                            a: 0,
                                            k: [rgb.r / 255, rgb.g / 255, rgb.b / 255, 1],
                                            ix: 3
                                        },
                                        o: { a: 0, k: 100, ix: 4 },
                                        w: { a: 0, k: segmentWidth, ix: 5 },
                                        lc: lineCap,
                                        lj: 2,
                                        bm: 0,
                                        nm: "Stroke 1",
                                        mn: "ADBE Vector Graphic - Stroke",
                                        hd: false
                                    },
                                    {
                                        ty: "tm",
                                        s: { a: 0, k: 0, ix: 1 },
                                        e: {
                                            a: 1,
                                            k: [
                                                { i: easing.i, o: easing.o, t: startFrame, s: [0] },
                                                { t: endFrame, s: [100] }
                                            ],
                                            ix: 2
                                        },
                                        o: { a: 0, k: 0, ix: 3 },
                                        m: 1,
                                        ix: 3,
                                        nm: "Trim Paths 1",
                                        mn: "ADBE Vector Filter - Trim",
                                        hd: false
                                    },
                                    {
                                        ty: "tr",
                                        p: { a: 0, k: [0, 0], ix: 2 },
                                        a: { a: 0, k: [0, 0], ix: 1 },
                                        s: { a: 0, k: [100, 100], ix: 3 },
                                        r: { a: 0, k: 0, ix: 6 },
                                        o: { a: 0, k: 100, ix: 7 },
                                        sk: { a: 0, k: 0, ix: 4 },
                                        sa: { a: 0, k: 0, ix: 5 },
                                        nm: "Transform"
                                    }
                                ],
                                nm: "Shape 1",
                                np: 3,
                                cix: 2,
                                bm: 0,
                                ix: 1,
                                mn: "ADBE Vector Group",
                                hd: false
                            }
                        ],
                        ip: 0,
                        op: totalDuration + 30,
                        st: 0,
                        bm: 0
                    };
                
                    lottieJSON.layers.push(layer);
                    layerIndex++;
                }
            });
            
            return lottieJSON;
        }
        
        // Exact conversion of canvas quadratic curves to Lottie cubic bezier
        function createSmoothBezierPath(points) {
            if (points.length < 2) {
                return {
                    i: [[0, 0]],
                    o: [[0, 0]],
                    v: [[points[0].x, points[0].y]],
                    c: false
                };
            }
            
            if (points.length === 2) {
                // Straight line with slight curve for smoothness
                const dx = (points[1].x - points[0].x) / 3;
                const dy = (points[1].y - points[0].y) / 3;
                return {
                    i: [[0, 0], [-dx, -dy]],
                    o: [[dx, dy], [0, 0]],
                    v: [[points[0].x, points[0].y], [points[1].x, points[1].y]],
                    c: false
                };
            }
            
            if (points.length === 3) {
                // Simple quadratic curve
                const p0 = points[0];
                const p1 = points[1];
                const p2 = points[2];
                
                const cp1 = {
                    x: p0.x + (2/3) * (p1.x - p0.x),
                    y: p0.y + (2/3) * (p1.y - p0.y)
                };
                const cp2 = {
                    x: p2.x + (2/3) * (p1.x - p2.x),
                    y: p2.y + (2/3) * (p1.y - p2.y)
                };
                
                return {
                    i: [[0, 0], [cp2.x - p2.x, cp2.y - p2.y]],
                    o: [[cp1.x - p0.x, cp1.y - p0.y], [0, 0]],
                    v: [[p0.x, p0.y], [p2.x, p2.y]],
                    c: false
                };
            }
            
            const vertices = [];
            const inTangents = [];
            const outTangents = [];
            
            // First point
            vertices.push([points[0].x, points[0].y]);
            inTangents.push([0, 0]);
            
            // First out tangent
            const firstCP1 = {
                x: points[0].x + (2/3) * (points[1].x - points[0].x),
                y: points[0].y + (2/3) * (points[1].y - points[0].y)
            };
            outTangents.push([
                firstCP1.x - points[0].x,
                firstCP1.y - points[0].y
            ]);
            
            // Middle vertices at midpoints
            for (let i = 1; i < points.length - 1; i++) {
                const p0 = points[i - 1];
                const p1 = points[i];
                const p2 = points[i + 1];
                
                const midEnd = {x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2};
                vertices.push([midEnd.x, midEnd.y]);
                
                const cp2 = {
                    x: midEnd.x + (2/3) * (p1.x - midEnd.x),
                    y: midEnd.y + (2/3) * (p1.y - midEnd.y)
                };
                inTangents.push([
                    cp2.x - midEnd.x,
                    cp2.y - midEnd.y
                ]);
                
                if (i < points.length - 2) {
                    const nextControl = points[i + 1];
                    const cp1Next = {
                        x: midEnd.x + (2/3) * (nextControl.x - midEnd.x),
                        y: midEnd.y + (2/3) * (nextControl.y - midEnd.y)
                    };
                    outTangents.push([
                        cp1Next.x - midEnd.x,
                        cp1Next.y - midEnd.y
                    ]);
                } else {
                    outTangents.push([0, 0]);
                }
            }
            
            // Last point
            const last = points[points.length - 1];
            vertices.push([last.x, last.y]);
            
            const secondLast = points[points.length - 2];
            const lastCP2 = {
                x: last.x + (2/3) * (secondLast.x - last.x),
                y: last.y + (2/3) * (secondLast.y - last.y)
            };
            inTangents.push([
                lastCP2.x - last.x,
                lastCP2.y - last.y
            ]);
            outTangents.push([0, 0]);
            
            return {
                i: inTangents,
                o: outTangents,
                v: vertices,
                c: false
            };
        }
        
        // Smooth path using quadratic interpolation (legacy, not used anymore)
        function smoothPath(points) {
            if (points.length < 3) {
                return points.map(p => [p.x, p.y]);
            }
            
            const smoothed = [];
            
            for (let i = 0; i < points.length - 2; i++) {
                const p0 = points[i];
                const p1 = points[i + 1];
                const p2 = points[i + 2];
                
                // Add midpoint
                smoothed.push([p0.x, p0.y]);
                
                // Add curved point using quadratic interpolation
                const midX = (p0.x + p1.x * 2 + p2.x) / 4;
                const midY = (p0.y + p1.y * 2 + p2.y) / 4;
                smoothed.push([midX, midY]);
            }
            
            // Add last two points
            smoothed.push([points[points.length - 2].x, points[points.length - 2].y]);
            smoothed.push([points[points.length - 1].x, points[points.length - 1].y]);
            
            return smoothed;
        }
        
        function downloadLottie(lottieData) {
            const jsonString = JSON.stringify(lottieData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `drawing-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function showPreview(lottieData) {
            previewArea.innerHTML = '<div id="lottiePreview" style="width: 100%; max-width: 800px;"></div>';
            
            if (lottieInstance) {
                lottieInstance.destroy();
            }
            
            const loopType = loopTypeInput.value;
            let loopSetting = true;
            
            if (loopType === 'once') {
                loopSetting = false;
            } else if (loopType === 'pingpong') {
                loopSetting = false; // We'll handle ping pong manually
            }
            
            lottieInstance = lottie.loadAnimation({
                container: document.getElementById('lottiePreview'),
                renderer: 'svg',
                loop: loopSetting,
                autoplay: true,
                animationData: lottieData
            });
            
            // Handle reverse loop
            if (loopType === 'reverse') {
                lottieInstance.setDirection(-1);
            }
            
            // Handle ping pong: play forward, then backward, repeat
            if (loopType === 'pingpong') {
                lottieInstance.setDirection(1); // Start forward
                
                lottieInstance.addEventListener('complete', function() {
                    // Flip direction and play again
                    lottieInstance.setDirection(lottieInstance.playDirection * -1);
                    lottieInstance.play();
                });
            }
        }
        
        function showStatus(message) {
            status.textContent = message;
            status.classList.add('active');
            setTimeout(() => {
                status.classList.remove('active');
            }, 3000);
        }
    </script>
</body>
</html>
