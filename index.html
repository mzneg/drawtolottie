<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawing to Lottie Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            padding: 20px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #222;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        
        .canvas-wrapper {
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 20px;
            background: white;
        }
        
        canvas {
            display: block;
            cursor: crosshair;
            touch-action: none;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button:hover {
            transform: translateY(-1px);
        }
        
        .btn-primary {
            background: #007bff;
            color: white;
        }
        
        .btn-primary:hover {
            background: #0056b3;
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #545b62;
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background: #218838;
        }
        
        .settings {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .setting-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        label {
            font-size: 14px;
            color: #555;
        }
        
        input[type="color"],
        input[type="range"],
        input[type="number"] {
            cursor: pointer;
        }
        
        input[type="range"] {
            width: 120px;
        }
        
        input[type="number"] {
            width: 80px;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .status {
            padding: 12px;
            background: #e7f3ff;
            border-left: 4px solid #007bff;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
            display: none;
        }
        
        .status.active {
            display: block;
        }
        
        .preview {
            margin-top: 30px;
            padding-top: 30px;
            border-top: 2px solid #eee;
        }
        
        .preview h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #222;
        }
        
        .preview-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            min-height: 200px;
            background: #fafafa;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #lottiePreview {
            max-width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Drawing to Lottie Animation</h1>
        <p class="subtitle">Draw with multiple brush types and export as Lottie with Framer Motion springs, custom curves, and loop options. Supports Apple Pencil and drawing tablet pressure.</p>
        
        <div class="settings">
            <div class="setting-group">
                <label>Brush:</label>
                <select id="brushType" style="padding: 6px 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                    <option value="solid">Solid</option>
                    <option value="flow">Flow (Smooth)</option>
                    <option value="marker">Marker</option>
                    <option value="spray">Spray</option>
                    <option value="pencil">Pencil</option>
                    <option value="calligraphy">Calligraphy</option>
                </select>
            </div>
            <div class="setting-group">
                <label>Color:</label>
                <input type="color" id="strokeColor" value="#000000">
                <input type="text" id="hexInput" value="#000000" maxlength="7" style="width: 80px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; text-transform: uppercase;">
            </div>
            <div class="setting-group">
                <label>Width:</label>
                <input type="range" id="strokeWidth" min="1" max="20" value="3">
                <span id="widthValue">3px</span>
            </div>
            <div class="setting-group">
                <label>Speed:</label>
                <input type="number" id="animationSpeed" min="0.1" max="5" step="0.1" value="1">
                <span>x</span>
            </div>
            <div class="setting-group">
                <label>Pressure:</label>
                <span id="pressureValue" style="font-weight: 500; color: #007bff;">0%</span>
            </div>
            <div class="setting-group">
                <input type="checkbox" id="pencilOnlyMode" style="cursor: pointer;">
                <label for="pencilOnlyMode" style="cursor: pointer;">Apple Pencil Only</label>
            </div>
            <div class="setting-group">
                <input type="checkbox" id="pressureSensitivity" checked style="cursor: pointer;">
                <label for="pressureSensitivity" style="cursor: pointer;">Pressure Sensitivity</label>
            </div>
            <div class="setting-group">
                <label>Smoothing:</label>
                <input type="range" id="smoothingStrength" min="0" max="100" value="60" style="width: 120px;">
                <span id="smoothingValue">60%</span>
            </div>
        </div>
        
        <div class="settings">
            <div class="setting-group">
                <label>Easing:</label>
                <select id="easingType" style="padding: 6px 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                    <optgroup label="Standard">
                        <option value="linear">Linear</option>
                        <option value="easeIn">Ease In</option>
                        <option value="easeOut">Ease Out</option>
                        <option value="easeInOut">Ease In-Out</option>
                        <option value="anticipate">Anticipate</option>
                        <option value="overshoot">Overshoot</option>
                    </optgroup>
                    <optgroup label="Framer Motion">
                        <option value="spring">Spring (Default)</option>
                        <option value="springBouncy">Spring (Bouncy)</option>
                        <option value="springSnappy">Spring (Snappy)</option>
                        <option value="springGentle">Spring (Gentle)</option>
                        <option value="springWobbly">Spring (Wobbly)</option>
                    </optgroup>
                    <option value="custom">Custom Curve</option>
                </select>
            </div>
            <div class="setting-group">
                <canvas id="easingPreview" width="150" height="40" style="border: 1px solid #ddd; border-radius: 4px; background: #fafafa;"></canvas>
            </div>
            <div class="setting-group">
                <label>Loop:</label>
                <select id="loopType" style="padding: 6px 12px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                    <option value="once">Play Once</option>
                    <option value="loop">Loop Forward</option>
                    <option value="reverse">Loop Reverse</option>
                    <option value="pingpong">Ping Pong</option>
                </select>
            </div>
        </div>
        
        <div class="settings" id="customCurveControls" style="display: none;">
            <div class="setting-group">
                <label>Custom Bezier Curve:</label>
            </div>
            <div class="setting-group">
                <label>X1:</label>
                <input type="number" id="curveX1" min="0" max="1" step="0.01" value="0.42">
            </div>
            <div class="setting-group">
                <label>Y1:</label>
                <input type="number" id="curveY1" min="-2" max="2" step="0.01" value="0">
            </div>
            <div class="setting-group">
                <label>X2:</label>
                <input type="number" id="curveX2" min="0" max="1" step="0.01" value="0.58">
            </div>
            <div class="setting-group">
                <label>Y2:</label>
                <input type="number" id="curveY2" min="-2" max="2" step="0.01" value="1">
            </div>
            <div class="setting-group">
                <canvas id="curvePreview" width="100" height="100" style="border: 1px solid #ddd; border-radius: 4px;"></canvas>
            </div>
        </div>
        
        <div class="settings" id="curvePresets" style="display: none; gap: 5px;">
            <div class="setting-group">
                <label>Presets:</label>
            </div>
            <button class="btn-secondary" style="padding: 6px 12px; font-size: 12px;" onclick="setCurve(0.42, 0, 1, 1)">Ease In</button>
            <button class="btn-secondary" style="padding: 6px 12px; font-size: 12px;" onclick="setCurve(0, 0, 0.58, 1)">Ease Out</button>
            <button class="btn-secondary" style="padding: 6px 12px; font-size: 12px;" onclick="setCurve(0.42, 0, 0.58, 1)">Ease In-Out</button>
            <button class="btn-secondary" style="padding: 6px 12px; font-size: 12px;" onclick="setCurve(0.68, -0.55, 0.265, 1.55)">Back</button>
            <button class="btn-secondary" style="padding: 6px 12px; font-size: 12px;" onclick="setCurve(0.175, 0.885, 0.32, 1.275)">Elastic</button>
        </div>
        
        <div class="canvas-wrapper">
            <canvas id="drawingCanvas" width="800" height="500"></canvas>
        </div>
        
        <div class="controls">
            <button class="btn-primary" id="clearBtn">Clear Canvas</button>
            <button class="btn-secondary" id="undoBtn">Undo</button>
            <button class="btn-secondary" id="redoBtn">Redo</button>
            <button class="btn-secondary" id="replayBtn">Replay Drawing</button>
            <button class="btn-secondary" id="previewAnimBtn">Preview Lottie</button>
            <button class="btn-success" id="exportBtn">Export Lottie JSON</button>
            <button class="btn-success" id="exportGifBtn">Export Transparent GIF</button>
            <button class="btn-success" id="exportSvgBtn">Export Animated SVG</button>
        </div>
        
        <div class="status" id="status"></div>
        
        <div class="preview">
            <h2>Preview Animation</h2>
            <div class="preview-area" id="previewArea">
                <p style="color: #999; text-align: center;">Your animation will appear here after export</p>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const brushTypeInput = document.getElementById('brushType');
        const strokeColorInput = document.getElementById('strokeColor');
        const hexInput = document.getElementById('hexInput');
        const strokeWidthInput = document.getElementById('strokeWidth');
        const widthValueSpan = document.getElementById('widthValue');
        const animationSpeedInput = document.getElementById('animationSpeed');
        const pressureValueSpan = document.getElementById('pressureValue');
        const pencilOnlyMode = document.getElementById('pencilOnlyMode');
        const pressureSensitivity = document.getElementById('pressureSensitivity');
        const smoothingStrength = document.getElementById('smoothingStrength');
        const smoothingValue = document.getElementById('smoothingValue');
        const easingTypeInput = document.getElementById('easingType');
        const loopTypeInput = document.getElementById('loopType');
        const customCurveControls = document.getElementById('customCurveControls');
        const curveX1Input = document.getElementById('curveX1');
        const curveY1Input = document.getElementById('curveY1');
        const curveX2Input = document.getElementById('curveX2');
        const curveY2Input = document.getElementById('curveY2');
        const curvePreviewCanvas = document.getElementById('curvePreview');
        const curvePreviewCtx = curvePreviewCanvas.getContext('2d');
        const easingPreviewCanvas = document.getElementById('easingPreview');
        const easingPreviewCtx = easingPreviewCanvas.getContext('2d');
        const curvePresets = document.getElementById('curvePresets');
        const clearBtn = document.getElementById('clearBtn');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const replayBtn = document.getElementById('replayBtn');
        const previewAnimBtn = document.getElementById('previewAnimBtn');
        const exportBtn = document.getElementById('exportBtn');
        const exportGifBtn = document.getElementById('exportGifBtn');
        const exportSvgBtn = document.getElementById('exportSvgBtn');
        const status = document.getElementById('status');
        const previewArea = document.getElementById('previewArea');
        
        let isDrawing = false;
        let strokes = [];
        let redoStack = [];
        let currentStroke = [];
        let startTime = 0;
        let lottieInstance = null;
        let easingAnimationFrame = null;
        
        // Function to set curve values
        function setCurve(x1, y1, x2, y2) {
            curveX1Input.value = x1;
            curveY1Input.value = y1;
            curveX2Input.value = x2;
            curveY2Input.value = y2;
            drawCurvePreview();
            animateEasingPreview();
        }
        
        // Make setCurve globally accessible for onclick handlers
        window.setCurve = setCurve;
        
        // Cubic bezier easing function
        function cubicBezier(t, p1x, p1y, p2x, p2y) {
            const cx = 3 * p1x;
            const bx = 3 * (p2x - p1x) - cx;
            const ax = 1 - cx - bx;
            const cy = 3 * p1y;
            const by = 3 * (p2y - p1y) - cy;
            const ay = 1 - cy - by;
            
            function sampleCurveX(t) {
                return ((ax * t + bx) * t + cx) * t;
            }
            
            function sampleCurveY(t) {
                return ((ay * t + by) * t + cy) * t;
            }
            
            function solveCurveX(x) {
                let t2 = x;
                for (let i = 0; i < 8; i++) {
                    const x2 = sampleCurveX(t2) - x;
                    if (Math.abs(x2) < 0.000001) return t2;
                    const d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                    if (Math.abs(d2) < 0.000001) break;
                    t2 = t2 - x2 / d2;
                }
                return t2;
            }
            
            return sampleCurveY(solveCurveX(t));
        }
        
        // Animate easing preview
        function animateEasingPreview() {
            if (easingAnimationFrame) {
                cancelAnimationFrame(easingAnimationFrame);
            }
            
            const width = easingPreviewCanvas.width;
            const height = easingPreviewCanvas.height;
            const ballRadius = 6;
            const startX = ballRadius + 5;
            const endX = width - ballRadius - 5;
            const y = height / 2;
            
            const duration = 1500; // 1.5 seconds
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Get easing values
                const easingType = easingTypeInput.value;
                const easing = getEasingValues(easingType);
                
                // Apply easing
                const easedProgress = cubicBezier(progress, easing.i.x[0], easing.i.y[0], easing.o.x[0], easing.o.y[0]);
                const x = startX + (endX - startX) * easedProgress;
                
                // Clear and draw
                easingPreviewCtx.clearRect(0, 0, width, height);
                
                // Draw track
                easingPreviewCtx.strokeStyle = '#ddd';
                easingPreviewCtx.lineWidth = 2;
                easingPreviewCtx.beginPath();
                easingPreviewCtx.moveTo(startX, y);
                easingPreviewCtx.lineTo(endX, y);
                easingPreviewCtx.stroke();
                
                // Draw ball
                easingPreviewCtx.fillStyle = '#007bff';
                easingPreviewCtx.beginPath();
                easingPreviewCtx.arc(x, y, ballRadius, 0, Math.PI * 2);
                easingPreviewCtx.fill();
                
                if (progress < 1) {
                    easingAnimationFrame = requestAnimationFrame(animate);
                } else {
                    // Loop the animation
                    setTimeout(() => animateEasingPreview(), 300);
                }
            }
            
            animate();
        }
        
        // Show/hide custom curve controls
        easingTypeInput.addEventListener('change', (e) => {
            if (e.target.value === 'custom') {
                customCurveControls.style.display = 'flex';
                curvePresets.style.display = 'flex';
                drawCurvePreview();
            } else {
                customCurveControls.style.display = 'none';
                curvePresets.style.display = 'none';
            }
            animateEasingPreview();
        });
        
        // Start easing preview on load
        setTimeout(() => animateEasingPreview(), 100);
        
        // Sync color picker and hex input
        strokeColorInput.addEventListener('input', (e) => {
            hexInput.value = e.target.value.toUpperCase();
        });
        
        hexInput.addEventListener('input', (e) => {
            let hex = e.target.value.trim();
            
            // Auto-add # if missing
            if (hex.length > 0 && !hex.startsWith('#')) {
                hex = '#' + hex;
                hexInput.value = hex;
            }
            
            // Validate hex format
            if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                strokeColorInput.value = hex;
            }
        });
        
        hexInput.addEventListener('blur', (e) => {
            // Ensure valid format on blur
            let hex = e.target.value.trim();
            if (!hex.startsWith('#')) {
                hex = '#' + hex;
            }
            
            // If not valid, reset to current color
            if (!/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                hexInput.value = strokeColorInput.value.toUpperCase();
            } else {
                hexInput.value = hex.toUpperCase();
                strokeColorInput.value = hex;
            }
        });
        
        // Update curve preview when values change
        curveX1Input.addEventListener('input', () => {
            drawCurvePreview();
            animateEasingPreview();
        });
        curveY1Input.addEventListener('input', () => {
            drawCurvePreview();
            animateEasingPreview();
        });
        curveX2Input.addEventListener('input', () => {
            drawCurvePreview();
            animateEasingPreview();
        });
        curveY2Input.addEventListener('input', () => {
            drawCurvePreview();
            animateEasingPreview();
        });
        
        function drawCurvePreview() {
            const x1 = parseFloat(curveX1Input.value);
            const y1 = parseFloat(curveY1Input.value);
            const x2 = parseFloat(curveX2Input.value);
            const y2 = parseFloat(curveY2Input.value);
            
            const width = curvePreviewCanvas.width;
            const height = curvePreviewCanvas.height;
            const padding = 10;
            
            curvePreviewCtx.clearRect(0, 0, width, height);
            
            // Draw grid
            curvePreviewCtx.strokeStyle = '#eee';
            curvePreviewCtx.lineWidth = 1;
            curvePreviewCtx.beginPath();
            curvePreviewCtx.moveTo(padding, padding);
            curvePreviewCtx.lineTo(padding, height - padding);
            curvePreviewCtx.lineTo(width - padding, height - padding);
            curvePreviewCtx.stroke();
            
            // Draw bezier curve
            curvePreviewCtx.strokeStyle = '#007bff';
            curvePreviewCtx.lineWidth = 2;
            curvePreviewCtx.beginPath();
            
            const startX = padding;
            const startY = height - padding;
            const endX = width - padding;
            const endY = padding;
            
            const cp1X = startX + (endX - startX) * x1;
            const cp1Y = startY - (startY - endY) * y1;
            const cp2X = startX + (endX - startX) * x2;
            const cp2Y = startY - (startY - endY) * y2;
            
            curvePreviewCtx.moveTo(startX, startY);
            curvePreviewCtx.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, endX, endY);
            curvePreviewCtx.stroke();
            
            // Draw control points
            curvePreviewCtx.fillStyle = '#007bff';
            curvePreviewCtx.beginPath();
            curvePreviewCtx.arc(cp1X, cp1Y, 3, 0, Math.PI * 2);
            curvePreviewCtx.arc(cp2X, cp2Y, 3, 0, Math.PI * 2);
            curvePreviewCtx.fill();
        }
        
        // Update width display
        strokeWidthInput.addEventListener('input', (e) => {
            widthValueSpan.textContent = e.target.value + 'px';
        });
        
        smoothingStrength.addEventListener('input', (e) => {
            smoothingValue.textContent = e.target.value + '%';
        });
        
        // Pointer events (supports mouse, touch, and stylus with pressure)
        canvas.addEventListener('pointerdown', startDrawing);
        canvas.addEventListener('pointermove', draw);
        canvas.addEventListener('pointerup', stopDrawing);
        canvas.addEventListener('pointerleave', stopDrawing);
        canvas.addEventListener('pointercancel', stopDrawing);
        
        function getPointerPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const rawPressure = e.pressure || 0.5;
            // If pressure sensitivity is off, use maximum pressure (1.0)
            const pressure = pressureSensitivity.checked ? rawPressure : 1.0;
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top,
                pressure: pressure
            };
        }
        
        function startDrawing(e) {
            // Check if pencil only mode is enabled
            if (pencilOnlyMode.checked && e.pointerType !== 'pen') {
                return; // Ignore touch and mouse input when pencil only mode is on
            }
            
            e.preventDefault();
            isDrawing = true;
            if (strokes.length === 0) {
                startTime = Date.now();
            }
            
            const pos = getPointerPosition(e);
            const baseWidth = parseInt(strokeWidthInput.value);
            
            // Update pressure display
            pressureValueSpan.textContent = Math.round(pos.pressure * 100) + '%';
            
            currentStroke = {
                points: [],
                color: strokeColorInput.value,
                baseWidth: baseWidth,
                brushType: brushTypeInput.value,
                startTime: Date.now() - startTime
            };
            
            currentStroke.points.push({
                x: pos.x,
                y: pos.y,
                pressure: pos.pressure,
                time: Date.now() - startTime
            });
        }
        
        function draw(e) {
            if (!isDrawing) return;
            
            if (pencilOnlyMode.checked && e.pointerType !== 'pen') {
                return;
            }
            
            e.preventDefault();
            
            const pos = getPointerPosition(e);
            const point = {
                x: pos.x,
                y: pos.y,
                pressure: pos.pressure,
                time: Date.now() - startTime
            };
            
            pressureValueSpan.textContent = Math.round(pos.pressure * 100) + '%';
            currentStroke.points.push(point);
            
            const len = currentStroke.points.length;
            if (len < 2) return;
            
            const brushType = currentStroke.brushType;
            
            ctx.strokeStyle = currentStroke.color;
            ctx.fillStyle = currentStroke.color;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            if (brushType === 'marker') {
                ctx.globalAlpha = 0.6;
            } else if (brushType === 'pencil') {
                ctx.globalAlpha = 0.7;
            } else {
                ctx.globalAlpha = 1.0;
            }
            
            const p1 = currentStroke.points[len - 2];
            const p2 = currentStroke.points[len - 1];
            
            const avgPressure = (p1.pressure + p2.pressure) / 2;
            const lineWidth = currentStroke.baseWidth * avgPressure;
            ctx.lineWidth = lineWidth;
            
            if (len === 2) {
                // First segment - just a line
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            } else {
                // Draw smooth quadratic curve
                const p0 = currentStroke.points[len - 3];
                
                // Midpoint between p0 and p1 is our start
                const startX = (p0.x + p1.x) / 2;
                const startY = (p0.y + p1.y) / 2;
                
                // Midpoint between p1 and p2 is our end
                const endX = (p1.x + p2.x) / 2;
                const endY = (p1.y + p2.y) / 2;
                
                // p1 is our control point
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.quadraticCurveTo(p1.x, p1.y, endX, endY);
                ctx.stroke();
                
                if (brushType === 'pencil') {
                    for (let i = 0; i < 2; i++) {
                        const offset = (Math.random() - 0.5) * lineWidth * 0.5;
                        ctx.lineWidth = 0.5;
                        ctx.globalAlpha = Math.random() * 0.3;
                        ctx.beginPath();
                        ctx.moveTo(startX + offset, startY + offset);
                        ctx.quadraticCurveTo(p1.x + offset, p1.y + offset, endX + offset, endY + offset);
                        ctx.stroke();
                        ctx.lineWidth = lineWidth;
                    }
                }
            }
            
            ctx.globalAlpha = 1.0;
        }
        
        function stopDrawing(e) {
            if (!isDrawing) return;
            if (e) e.preventDefault();
            isDrawing = false;
            pressureValueSpan.textContent = '0%';
            if (currentStroke.points.length > 0) {
                // Apply intelligent smoothing automatically
                currentStroke = applyAutoSmoothing(currentStroke);
                strokes.push(currentStroke);
                redoStack = []; // Clear redo history when new stroke is added
                // Redraw to show smoothed stroke
                redrawCanvas();
            }
        }
        
        // Clear canvas
        clearBtn.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            strokes = [];
            redoStack = [];
            startTime = 0;
            pressureValueSpan.textContent = '0%';
            showStatus('Canvas cleared');
        });
        
        // Redraw canvas from strokes
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            strokes.forEach(stroke => {
                const brushType = stroke.brushType;
                
                ctx.strokeStyle = stroke.color;
                ctx.fillStyle = stroke.color;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                if (brushType === 'marker') {
                    ctx.globalAlpha = 0.6;
                } else if (brushType === 'pencil') {
                    ctx.globalAlpha = 0.7;
                } else {
                    ctx.globalAlpha = 1.0;
                }
                
                for (let i = 1; i < stroke.points.length; i++) {
                    const p1 = stroke.points[i - 1];
                    const p2 = stroke.points[i];
                    
                    const avgPressure = (p1.pressure + p2.pressure) / 2;
                    const lineWidth = stroke.baseWidth * avgPressure;
                    ctx.lineWidth = lineWidth;
                    
                    if (i === 1) {
                        // First segment
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    } else {
                        // Smooth curve
                        const p0 = stroke.points[i - 2];
                        
                        const startX = (p0.x + p1.x) / 2;
                        const startY = (p0.y + p1.y) / 2;
                        const endX = (p1.x + p2.x) / 2;
                        const endY = (p1.y + p2.y) / 2;
                        
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.quadraticCurveTo(p1.x, p1.y, endX, endY);
                        ctx.stroke();
                        
                        if (brushType === 'pencil') {
                            for (let j = 0; j < 2; j++) {
                                const offset = (Math.random() - 0.5) * lineWidth * 0.5;
                                ctx.lineWidth = 0.5;
                                ctx.globalAlpha = Math.random() * 0.3;
                                ctx.beginPath();
                                ctx.moveTo(startX + offset, startY + offset);
                                ctx.quadraticCurveTo(p1.x + offset, p1.y + offset, endX + offset, endY + offset);
                                ctx.stroke();
                                ctx.lineWidth = lineWidth;
                            }
                        }
                    }
                }
                
                ctx.globalAlpha = 1.0;
            });
        }
        
        // Intelligent smoothing that preserves shape AND pressure
        function smoothStroke(points, strength) {
            if (points.length < 3) return points;
            if (strength === 0) return points;
            
            // Step 1: Simplify path while preserving key shape points
            const epsilon = (strength / 100) * 5; // Reduced from 10 for gentler simplification
            const simplified = rdpSimplify(points, epsilon);
            
            // Step 2: Interpolate pressure values to smooth transitions
            const withPressure = interpolatePressure(simplified, points);
            
            // Step 3: Apply gentle Chaikin smoothing only at lower strengths
            const iterations = Math.floor(strength / 50); // 0-2 iterations max
            let smoothed = withPressure;
            for (let i = 0; i < iterations; i++) {
                smoothed = chaikinSmooth(smoothed);
            }
            
            return smoothed;
        }
        
        // Interpolate pressure values from original stroke
        function interpolatePressure(simplified, original) {
            return simplified.map(point => {
                // Find the closest original point
                let minDist = Infinity;
                let closestPoint = original[0];
                
                for (const origPoint of original) {
                    const dist = Math.sqrt(
                        Math.pow(point.x - origPoint.x, 2) + 
                        Math.pow(point.y - origPoint.y, 2)
                    );
                    if (dist < minDist) {
                        minDist = dist;
                        closestPoint = origPoint;
                    }
                }
                
                // Use pressure from closest original point
                return {
                    x: point.x,
                    y: point.y,
                    pressure: closestPoint.pressure,
                    time: point.time
                };
            });
        }
        
        // Ramer-Douglas-Peucker algorithm - simplifies path while preserving shape
        function rdpSimplify(points, epsilon) {
            if (points.length < 3) return points;
            
            // Find point with maximum distance from line between start and end
            let maxDist = 0;
            let maxIndex = 0;
            const start = points[0];
            const end = points[points.length - 1];
            
            for (let i = 1; i < points.length - 1; i++) {
                const dist = perpendicularDistance(points[i], start, end);
                if (dist > maxDist) {
                    maxDist = dist;
                    maxIndex = i;
                }
            }
            
            // If max distance is greater than epsilon, recursively simplify
            if (maxDist > epsilon) {
                const left = rdpSimplify(points.slice(0, maxIndex + 1), epsilon);
                const right = rdpSimplify(points.slice(maxIndex), epsilon);
                // Remove duplicate middle point
                return [...left.slice(0, -1), ...right];
            } else {
                // Keep start and end with original pressure values
                return [
                    { ...start },
                    { ...end }
                ];
            }
        }
        
        // Calculate perpendicular distance from point to line
        function perpendicularDistance(point, lineStart, lineEnd) {
            const dx = lineEnd.x - lineStart.x;
            const dy = lineEnd.y - lineStart.y;
            const mag = Math.sqrt(dx * dx + dy * dy);
            if (mag === 0) return 0;
            
            const u = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (mag * mag);
            const closestX = lineStart.x + u * dx;
            const closestY = lineStart.y + u * dy;
            
            return Math.sqrt(Math.pow(point.x - closestX, 2) + Math.pow(point.y - closestY, 2));
        }
        
        // Chaikin's corner cutting algorithm - creates smooth curves with proper pressure interpolation
        function chaikinSmooth(points) {
            if (points.length < 3) return points;
            
            const smoothed = [points[0]]; // Keep first point
            
            for (let i = 0; i < points.length - 1; i++) {
                const p0 = points[i];
                const p1 = points[i + 1];
                
                // Create two points 1/4 and 3/4 along the segment
                // Interpolate pressure smoothly
                const q = {
                    x: 0.75 * p0.x + 0.25 * p1.x,
                    y: 0.75 * p0.y + 0.25 * p1.y,
                    pressure: 0.75 * p0.pressure + 0.25 * p1.pressure, // Smooth pressure interpolation
                    time: p0.time
                };
                
                const r = {
                    x: 0.25 * p0.x + 0.75 * p1.x,
                    y: 0.25 * p0.y + 0.75 * p1.y,
                    pressure: 0.25 * p0.pressure + 0.75 * p1.pressure, // Smooth pressure interpolation
                    time: p1.time
                };
                
                smoothed.push(q);
                smoothed.push(r);
            }
            
            smoothed.push(points[points.length - 1]); // Keep last point
            return smoothed;
        }
        
        // Apply smoothing automatically when stroke ends
        function applyAutoSmoothing(stroke) {
            const strength = parseInt(smoothingStrength.value);
            if (strength > 0) {
                stroke.points = smoothStroke(stroke.points, strength);
            }
            return stroke;
        }
        
        // Legacy function - no longer needed but keeping for compatibility
        function applySmoothingToAllStrokes() {
            const strength = parseInt(smoothingStrength.value);
            
            if (strokes.length === 0) {
                alert('No strokes to smooth!');
                return;
            }
            
            strokes.forEach(stroke => {
                stroke.points = smoothStroke(stroke.points, strength);
            });
            
            redrawCanvas();
        }
        
        // Undo
        undoBtn.addEventListener('click', () => {
            if (strokes.length === 0) {
                showStatus('Nothing to undo');
                return;
            }
            
            const lastStroke = strokes.pop();
            redoStack.push(lastStroke);
            redrawCanvas();
            showStatus('Undo successful');
        });
        
        // Redo
        redoBtn.addEventListener('click', () => {
            if (redoStack.length === 0) {
                showStatus('Nothing to redo');
                return;
            }
            
            const strokeToRestore = redoStack.pop();
            strokes.push(strokeToRestore);
            redrawCanvas();
            showStatus('Redo successful');
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl+Z or Cmd+Z for undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undoBtn.click();
            }
            // Ctrl+Y or Cmd+Y or Ctrl+Shift+Z for redo
            else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.shiftKey && e.key === 'z'))) {
                e.preventDefault();
                redoBtn.click();
            }
        });
        
        // Touch gestures for iPad (two-finger tap = undo, three-finger tap = redo)
        let touchStartTime = 0;
        let touchCount = 0;
        const tapTimeout = 300; // Maximum time for a tap in milliseconds
        
        canvas.addEventListener('touchstart', (e) => {
            touchCount = e.touches.length;
            touchStartTime = Date.now();
        }, { passive: true });
        
        canvas.addEventListener('touchend', (e) => {
            const touchDuration = Date.now() - touchStartTime;
            
            // Only trigger if it was a quick tap (not a drag)
            if (touchDuration < tapTimeout) {
                // Two-finger tap for undo
                if (touchCount === 2) {
                    e.preventDefault();
                    undoBtn.click();
                }
                // Three-finger tap for redo
                else if (touchCount === 3) {
                    e.preventDefault();
                    redoBtn.click();
                }
            }
        });
        
        // Replay animation
        replayBtn.addEventListener('click', () => {
            if (strokes.length === 0) {
                showStatus('Nothing to replay. Draw something first.');
                return;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            showStatus('Replaying animation...');
            
            const speed = parseFloat(animationSpeedInput.value);
            let strokeIndex = 0;
            let pointIndex = 0;
            
            function animate() {
                if (strokeIndex >= strokes.length) {
                    showStatus('Replay complete');
                    return;
                }
                
                const stroke = strokes[strokeIndex];
                
                if (pointIndex < stroke.points.length) {
                    if (pointIndex > 0) {
                        const prevPoint = stroke.points[pointIndex - 1];
                        const currPoint = stroke.points[pointIndex];
                        const avgPressure = (prevPoint.pressure + currPoint.pressure) / 2;
                        const lineWidth = stroke.baseWidth * avgPressure;
                        
                        ctx.strokeStyle = stroke.color;
                        ctx.fillStyle = stroke.color;
                        ctx.lineJoin = 'round';
                        
                        const brushType = stroke.brushType;
                        
                        if (brushType === 'solid') {
                            ctx.lineWidth = lineWidth;
                            ctx.lineCap = 'round';
                            ctx.beginPath();
                            ctx.moveTo(prevPoint.x, prevPoint.y);
                            ctx.lineTo(currPoint.x, currPoint.y);
                            ctx.stroke();
                        } else if (brushType === 'flow') {
                            ctx.lineWidth = lineWidth;
                            ctx.lineCap = 'round';
                            
                            if (pointIndex > 1) {
                                const prevPrevPoint = stroke.points[pointIndex - 2];
                                const midX = (prevPrevPoint.x + prevPoint.x) / 2;
                                const midY = (prevPrevPoint.y + prevPoint.y) / 2;
                                const midX2 = (prevPoint.x + currPoint.x) / 2;
                                const midY2 = (prevPoint.y + currPoint.y) / 2;
                                
                                ctx.beginPath();
                                ctx.moveTo(midX, midY);
                                ctx.quadraticCurveTo(prevPoint.x, prevPoint.y, midX2, midY2);
                                ctx.stroke();
                            } else {
                                ctx.beginPath();
                                ctx.moveTo(prevPoint.x, prevPoint.y);
                                ctx.lineTo(currPoint.x, currPoint.y);
                                ctx.stroke();
                            }
                        } else if (brushType === 'marker') {
                            ctx.lineWidth = lineWidth;
                            ctx.lineCap = 'butt';
                            ctx.globalAlpha = 0.6;
                            ctx.beginPath();
                            ctx.moveTo(prevPoint.x, prevPoint.y);
                            ctx.lineTo(currPoint.x, currPoint.y);
                            ctx.stroke();
                            ctx.globalAlpha = 1.0;
                        } else if (brushType === 'spray') {
                            const distance = Math.sqrt(Math.pow(currPoint.x - prevPoint.x, 2) + Math.pow(currPoint.y - prevPoint.y, 2));
                            const density = Math.max(1, Math.floor(distance / 2));
                            
                            for (let i = 0; i < density; i++) {
                                const t = i / density;
                                const x = prevPoint.x + (currPoint.x - prevPoint.x) * t;
                                const y = prevPoint.y + (currPoint.y - prevPoint.y) * t;
                                
                                const sprayRadius = lineWidth * 2;
                                const offsetX = (Math.random() - 0.5) * sprayRadius;
                                const offsetY = (Math.random() - 0.5) * sprayRadius;
                                
                                ctx.globalAlpha = Math.random() * 0.5 + 0.3;
                                ctx.beginPath();
                                ctx.arc(x + offsetX, y + offsetY, Math.random() * 1.5, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            ctx.globalAlpha = 1.0;
                        } else if (brushType === 'pencil') {
                            ctx.lineWidth = lineWidth;
                            ctx.lineCap = 'butt';
                            ctx.globalAlpha = 0.7;
                            ctx.beginPath();
                            ctx.moveTo(prevPoint.x, prevPoint.y);
                            ctx.lineTo(currPoint.x, currPoint.y);
                            ctx.stroke();
                            
                            for (let i = 0; i < 3; i++) {
                                const offset = (Math.random() - 0.5) * lineWidth * 0.5;
                                ctx.lineWidth = 0.5;
                                ctx.globalAlpha = Math.random() * 0.3;
                                ctx.beginPath();
                                ctx.moveTo(prevPoint.x + offset, prevPoint.y + offset);
                                ctx.lineTo(currPoint.x + offset, currPoint.y + offset);
                                ctx.stroke();
                            }
                            ctx.globalAlpha = 1.0;
                        } else if (brushType === 'calligraphy') {
                            const angle = Math.atan2(currPoint.y - prevPoint.y, currPoint.x - prevPoint.x);
                            const calligraphyAngle = Math.PI / 4;
                            const widthMultiplier = Math.abs(Math.cos(angle - calligraphyAngle)) * 0.7 + 0.3;
                            
                            ctx.lineWidth = lineWidth * widthMultiplier;
                            ctx.lineCap = 'butt';
                            ctx.beginPath();
                            ctx.moveTo(prevPoint.x, prevPoint.y);
                            ctx.lineTo(currPoint.x, currPoint.y);
                            ctx.stroke();
                        }
                    }
                    
                    pointIndex++;
                    
                    if (pointIndex < stroke.points.length) {
                        const delay = (stroke.points[pointIndex].time - stroke.points[pointIndex - 1].time) / speed;
                        setTimeout(animate, delay);
                    } else {
                        strokeIndex++;
                        pointIndex = 0;
                        setTimeout(animate, 10 / speed); // Minimal delay between strokes
                    }
                }
            }
            
            animate();
        });
        
        // Preview Lottie animation
        previewAnimBtn.addEventListener('click', () => {
            if (strokes.length === 0) {
                showStatus('Nothing to preview. Draw something first.');
                return;
            }
            
            const lottieData = generateLottieJSON();
            showPreview(lottieData);
            showStatus('Preview loaded successfully!');
        });
        
        // Export to Lottie
        exportBtn.addEventListener('click', () => {
            if (strokes.length === 0) {
                showStatus('Nothing to export. Draw something first.');
                return;
            }
            
            const lottieData = generateLottieJSON();
            downloadLottie(lottieData);
            showPreview(lottieData);
            showStatus('Lottie JSON exported successfully!');
        });
        
        exportGifBtn.addEventListener('click', async () => {
            if (strokes.length === 0) {
                showStatus('Nothing to export. Draw something first.');
                return;
            }
            
            showStatus('Generating transparent GIF... This may take a moment.');
            try {
                await exportTransparentGif();
                showStatus('Transparent GIF exported successfully!');
            } catch (error) {
                showStatus('Error generating GIF: ' + error.message);
                console.error(error);
            }
        });
        
        exportSvgBtn.addEventListener('click', () => {
            if (strokes.length === 0) {
                showStatus('Nothing to export. Draw something first.');
                return;
            }
            
            try {
                exportAnimatedSVG();
                showStatus('Animated SVG exported successfully!');
            } catch (error) {
                showStatus('Error generating SVG: ' + error.message);
                console.error(error);
            }
        });
        
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16) / 255,
                g: parseInt(result[2], 16) / 255,
                b: parseInt(result[3], 16) / 255
            } : { r: 0, g: 0, b: 0 };
        }
        
        // Export transparent GIF using canvas frames
        async function exportTransparentGif() {
            const speed = parseFloat(animationSpeedInput.value);
            const fps = 30;
            
            // Calculate duration
            const maxTime = Math.max(...strokes.flatMap(s => s.points.map(p => p.time)));
            const totalDuration = (maxTime / 1000 / speed);
            const frameCount = Math.ceil(totalDuration * fps);
            const frameDelay = 1000 / fps;
            
            // Create a temporary canvas for rendering
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Use GIF.js library (loading from CDN)
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js';
            document.head.appendChild(script);
            
            await new Promise((resolve, reject) => {
                script.onload = resolve;
                script.onerror = reject;
            });
            
            const gif = new GIF({
                workers: 2,
                quality: 10,
                width: canvas.width,
                height: canvas.height,
                transparent: 0x000000, // Use black as transparent color
                workerScript: 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js'
            });
            
            // Render each frame
            for (let frame = 0; frame <= frameCount; frame++) {
                const currentTime = (frame / fps) * 1000 * speed;
                
                // Clear with transparent background (black will become transparent)
                tempCtx.fillStyle = '#000000';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                
                // Draw strokes up to current time
                strokes.forEach(stroke => {
                    const relevantPoints = stroke.points.filter(p => p.time <= currentTime);
                    if (relevantPoints.length < 2) return;
                    
                    tempCtx.strokeStyle = stroke.color;
                    tempCtx.globalAlpha = 1.0;
                    
                    if (stroke.brushType === 'marker') {
                        tempCtx.globalAlpha = 0.6;
                    } else if (stroke.brushType === 'pencil') {
                        tempCtx.globalAlpha = 0.7;
                    }
                    
                    tempCtx.lineCap = 'round';
                    tempCtx.lineJoin = 'round';
                    
                    for (let i = 0; i < relevantPoints.length - 1; i++) {
                        const p1 = relevantPoints[i];
                        const p2 = relevantPoints[i + 1];
                        const lineWidth = stroke.baseWidth * ((p1.pressure + p2.pressure) / 2);
                        
                        tempCtx.lineWidth = lineWidth;
                        tempCtx.beginPath();
                        
                        if (i === 0) {
                            tempCtx.moveTo(p1.x, p1.y);
                        }
                        
                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        tempCtx.quadraticCurveTo(p1.x, p1.y, midX, midY);
                        tempCtx.stroke();
                    }
                });
                
                tempCtx.globalAlpha = 1.0;
                gif.addFrame(tempCtx, {copy: true, delay: frameDelay});
            }
            
            gif.on('finished', function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'drawing-animation.gif';
                a.click();
                URL.revokeObjectURL(url);
            });
            
            gif.render();
        }
        
        // Export animated SVG
        function exportAnimatedSVG() {
            const speed = parseFloat(animationSpeedInput.value);
            const easingType = easingTypeInput.value;
            
            // Calculate total duration
            const maxTime = Math.max(...strokes.flatMap(s => s.points.map(p => p.time)));
            const totalDuration = (maxTime / 1000 / speed);
            
            // Start building SVG
            let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}" viewBox="0 0 ${canvas.width} ${canvas.height}">
    <defs>
        <style>
            .stroke-anim { animation-timing-function: ${getEasingCSS(easingType)}; }
        </style>
    </defs>
    <g id="drawing">
`;
            
            // Add each stroke as a path with animation
            strokes.forEach((stroke, strokeIdx) => {
                const points = stroke.points;
                if (points.length < 2) return;
                
                // Calculate timing for this stroke
                const strokeStartTime = (points[0].time / 1000 / speed);
                const strokeEndTime = (points[points.length - 1].time / 1000 / speed);
                const strokeDuration = strokeEndTime - strokeStartTime;
                
                // Build SVG path
                let pathData = `M ${points[0].x},${points[0].y}`;
                
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2;
                    pathData += ` Q ${p1.x},${p1.y} ${midX},${midY}`;
                }
                
                // Average stroke width based on pressure
                const avgPressure = points.reduce((sum, p) => sum + p.pressure, 0) / points.length;
                const strokeWidth = stroke.baseWidth * avgPressure;
                
                // Opacity based on brush type
                let opacity = 1;
                if (stroke.brushType === 'marker') {
                    opacity = 0.6;
                } else if (stroke.brushType === 'pencil') {
                    opacity = 0.7;
                }
                
                // Calculate path length for animation
                svg += `
        <path id="stroke-${strokeIdx}" 
              d="${pathData}" 
              fill="none" 
              stroke="${stroke.color}" 
              stroke-width="${strokeWidth}" 
              stroke-linecap="round" 
              stroke-linejoin="round" 
              opacity="${opacity}"
              pathLength="100">
            <animate attributeName="stroke-dasharray" 
                     from="0 100" 
                     to="100 0" 
                     begin="${strokeStartTime}s" 
                     dur="${strokeDuration}s" 
                     fill="freeze" 
                     class="stroke-anim"/>
            <animate attributeName="stroke-dashoffset" 
                     from="0" 
                     to="0" 
                     begin="${strokeStartTime}s" 
                     dur="${strokeDuration}s" 
                     fill="freeze"/>
        </path>`;
            });
            
            svg += `
    </g>
</svg>`;
            
            // Download SVG
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'drawing-animation.svg';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Convert easing type to CSS timing function
        function getEasingCSS(easingType) {
            const easings = {
                linear: 'linear',
                easeIn: 'cubic-bezier(0.42, 0, 1, 1)',
                easeOut: 'cubic-bezier(0, 0, 0.58, 1)',
                easeInOut: 'cubic-bezier(0.42, 0, 0.58, 1)',
                anticipate: 'cubic-bezier(0.36, 0, 0.66, -0.56)',
                overshoot: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
                spring: 'cubic-bezier(0.16, 1, 0.3, 1)',
                springBouncy: 'cubic-bezier(0.68, -0.6, 0.32, 1.6)',
                springSnappy: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
                springGentle: 'cubic-bezier(0.25, 0.1, 0.25, 1)',
                springWobbly: 'cubic-bezier(0.8, -0.9, 0.2, 1.9)'
            };
            return easings[easingType] || 'linear';
        }
        
        // Create filled shape segments with variable width for pressure-sensitive strokes
        
        function getEasingValues(easingType) {
            // Custom curve
            if (easingType === 'custom') {
                const x1 = parseFloat(curveX1Input.value);
                const y1 = parseFloat(curveY1Input.value);
                const x2 = parseFloat(curveX2Input.value);
                const y2 = parseFloat(curveY2Input.value);
                return { i: { x: [x1], y: [y1] }, o: { x: [x2], y: [y2] } };
            }
            
            const easings = {
                // Standard easings
                linear: { i: { x: [0], y: [0] }, o: { x: [1], y: [1] } },
                easeIn: { i: { x: [0.42], y: [0] }, o: { x: [1], y: [1] } },
                easeOut: { i: { x: [0], y: [0] }, o: { x: [0.58], y: [1] } },
                easeInOut: { i: { x: [0.42], y: [0] }, o: { x: [0.58], y: [1] } },
                anticipate: { i: { x: [0.36], y: [0] }, o: { x: [0.66], y: [-0.56] } },
                overshoot: { i: { x: [0.34], y: [1.56] }, o: { x: [0.64], y: [1] } },
                
                // Framer Motion spring animations (better approximations)
                // True springs need physics, but these bezier curves feel spring-like
                spring: { i: { x: [0.16], y: [1] }, o: { x: [0.3], y: [1] } }, // Default spring
                springBouncy: { i: { x: [0.68], y: [-0.6] }, o: { x: [0.32], y: [1.6] } }, // More bounce
                springSnappy: { i: { x: [0.34], y: [1.56] }, o: { x: [0.64], y: [1] } }, // Quick settle
                springGentle: { i: { x: [0.25], y: [0.1] }, o: { x: [0.25], y: [1] } }, // Soft and smooth
                springWobbly: { i: { x: [0.8], y: [-0.9] }, o: { x: [0.2], y: [1.9] } } // Max overshoot
            };
            return easings[easingType] || easings.linear;
        }
        
        // Apply easing curve to a progress value (0-1)
        function applyEasingToProgress(t, easingType) {
            if (t <= 0) return 0;
            if (t >= 1) return 1;
            
            let result;
            
            // Handle custom curve
            if (easingType === 'custom') {
                const x1 = parseFloat(curveX1Input.value);
                const y1 = parseFloat(curveY1Input.value);
                const x2 = parseFloat(curveX2Input.value);
                const y2 = parseFloat(curveY2Input.value);
                result = cubicBezier(t, x1, y1, x2, y2);
                return result;
            }
            
            // Mathematical easing functions
            switch(easingType) {
                case 'linear':
                    result = t;
                    break;
                    
                case 'easeIn': // cubic-bezier(0.42, 0, 1, 1)
                    result = t * t * t;
                    break;
                    
                case 'easeOut': // cubic-bezier(0, 0, 0.58, 1)
                    result = 1 - Math.pow(1 - t, 3);
                    break;
                    
                case 'easeInOut': // cubic-bezier(0.42, 0, 0.58, 1)
                    result = t < 0.5 
                        ? 4 * t * t * t 
                        : 1 - Math.pow(-2 * t + 2, 3) / 2;
                    break;
                    
                case 'anticipate':
                    const c1 = 1.70158;
                    const c2 = c1 * 1.525;
                    result = t < 0.5
                        ? (Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2
                        : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
                    break;
                    
                case 'overshoot':
                    const c3 = 1.70158;
                    const c4 = c3 + 1;
                    result = 1 + c4 * Math.pow(t - 1, 3) + c3 * Math.pow(t - 1, 2);
                    break;
                    
                case 'spring':
                case 'springSnappy':
                    // Approximation of spring with damping
                    const decay = Math.pow(2, -10 * t);
                    result = 1 - decay * Math.cos((t * 7 - 0.75) * Math.PI * 2);
                    break;
                    
                case 'springBouncy':
                    const n1 = 7.5625;
                    const d1 = 2.75;
                    if (t < 1 / d1) {
                        result = n1 * t * t;
                    } else if (t < 2 / d1) {
                        result = n1 * (t -= 1.5 / d1) * t + 0.75;
                    } else if (t < 2.5 / d1) {
                        result = n1 * (t -= 2.25 / d1) * t + 0.9375;
                    } else {
                        result = n1 * (t -= 2.625 / d1) * t + 0.984375;
                    }
                    break;
                    
                case 'springGentle':
                    // Gentle ease out
                    result = 1 - Math.pow(1 - t, 2);
                    break;
                    
                case 'springWobbly':
                    // Elastic overshoot
                    const c5 = (2 * Math.PI) / 3;
                    result = t === 0 ? 0 : t === 1 ? 1 :
                        Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c5) + 1;
                    break;
                    
                default:
                    result = t;
            }
            
            return result;
        }
        
        function generateLottieJSON() {
            const speed = parseFloat(animationSpeedInput.value);
            const fps = 30; // Lower FPS for better performance
            const easingType = easingTypeInput.value;
            const loopType = loopTypeInput.value;
            
            // Calculate total duration
            let maxTime = 0;
            strokes.forEach(stroke => {
                const lastPoint = stroke.points[stroke.points.length - 1];
                if (lastPoint.time > maxTime) {
                    maxTime = lastPoint.time;
                }
            });
            
            const totalDuration = (maxTime / 1000 / speed) * fps;
            
            // Handle different loop types
            let loopValue = true;
            let direction = 1;
            
            if (loopType === 'once') {
                loopValue = false;
            } else if (loopType === 'reverse') {
                loopValue = true;
                direction = -1;
            } else if (loopType === 'pingpong') {
                loopValue = 2;
            }
            
            const lottieJSON = {
                v: "5.7.4",
                fr: fps,
                ip: 0,
                op: totalDuration + 30,
                w: canvas.width,
                h: canvas.height,
                nm: "Drawing Animation",
                ddd: 0,
                assets: [],
                layers: [],
                markers: []
            };
            
            lottieJSON.meta = {
                loop: loopValue,
                direction: direction
            };
            
            // Create segments with pressure sensitivity
            let layerIndex = 0;
            
            strokes.forEach((stroke, strokeIdx) => {
                const rgb = hexToRgb(stroke.color);
                const easing = getEasingValues(easingType);
                
                const strokePoints = stroke.points;
                if (strokePoints.length < 2) return;
                
                // Calculate overall drawing timeline ONCE
                const drawingStartTime = strokes[0].points[0].time;
                const drawingEndTime = strokes[strokes.length - 1].points[strokes[strokes.length - 1].points.length - 1].time;
                const totalDrawingDuration = drawingEndTime - drawingStartTime;
                const overallEndFrame = (totalDrawingDuration / 1000 / speed) * fps;
                
                // Check if stroke has significant pressure variation
                const pressures = strokePoints.map(p => p.pressure);
                const minPressure = Math.min(...pressures);
                const maxPressure = Math.max(...pressures);
                const hasPressureVariation = (maxPressure - minPressure) > 0.3; // 30% variation threshold (increased)
                
                if (hasPressureVariation) {
                    // Use filled shapes for pressure-sensitive strokes
                    // Smaller segments for smoother drawing appearance
                    const segmentSize = 8;
                    const stepSize = 6;
                    
                    for (let i = 0; i < strokePoints.length - 1; i += stepSize) {
                        const endIdx = Math.min(i + segmentSize, strokePoints.length);
                        const segmentPoints = strokePoints.slice(i, endIdx);
                        
                        if (segmentPoints.length < 2) continue;
                        
                        // Create variable-width outline
                        const leftEdge = [];
                        const rightEdge = [];
                        
                        for (let j = 0; j < segmentPoints.length; j++) {
                            const p = segmentPoints[j];
                            const width = stroke.baseWidth * p.pressure;
                            const halfWidth = width / 2;
                            
                            // Calculate perpendicular direction
                            let perpX, perpY;
                            const globalIdx = i + j;
                            
                            if (globalIdx === 0) {
                                const next = strokePoints[globalIdx + 1];
                                const dx = next.x - p.x;
                                const dy = next.y - p.y;
                                const len = Math.sqrt(dx * dx + dy * dy) || 1;
                                perpX = -dy / len;
                                perpY = dx / len;
                            } else if (globalIdx === strokePoints.length - 1) {
                                const prev = strokePoints[globalIdx - 1];
                                const dx = p.x - prev.x;
                                const dy = p.y - prev.y;
                                const len = Math.sqrt(dx * dx + dy * dy) || 1;
                                perpX = -dy / len;
                                perpY = dx / len;
                            } else {
                                const prev = strokePoints[Math.max(0, globalIdx - 1)];
                                const next = strokePoints[Math.min(strokePoints.length - 1, globalIdx + 1)];
                                const dx = next.x - prev.x;
                                const dy = next.y - prev.y;
                                const len = Math.sqrt(dx * dx + dy * dy) || 1;
                                perpX = -dy / len;
                                perpY = dx / len;
                            }
                            
                            leftEdge.push({
                                x: p.x + perpX * halfWidth,
                                y: p.y + perpY * halfWidth,
                                pressure: 1,
                                time: p.time
                            });
                            
                            rightEdge.push({
                                x: p.x - perpX * halfWidth,
                                y: p.y - perpY * halfWidth,
                                pressure: 1,
                                time: p.time
                            });
                        }
                        
                        // Create closed shape
                        const shapePoints = [...leftEdge, ...rightEdge.reverse()];
                        const bezierPath = createSmoothBezierPath(shapePoints);
                        bezierPath.c = true;
                        
                        const startTime = segmentPoints[0].time;
                        
                        // GLOBAL EASING: Apply easing to determine WHEN this segment appears
                        // Linear progress through the drawing (0 to 1)
                        const linearProgress = (startTime - drawingStartTime) / totalDrawingDuration;
                        // Apply easing to get the EASED appearance time
                        const easedProgress = applyEasingToProgress(linearProgress, easingType);
                        // Convert to frame number
                        const appearFrame = Math.round(easedProgress * overallEndFrame);
                        
                        let opacity = 100;
                        if (stroke.brushType === 'marker') {
                            opacity = 60;
                        } else if (stroke.brushType === 'pencil') {
                            opacity = 70;
                        }
                        
                        // Layer appears INSTANTLY at the eased time (no fade)
                        const layer = {
                            ddd: 0,
                            ind: layerIndex + 1,
                            ty: 4,
                            nm: `Stroke ${strokeIdx + 1} Seg ${Math.floor(i / stepSize)}`,
                            sr: 1,
                            ks: {
                                o: { a: 0, k: opacity, ix: 11 },
                                r: { a: 0, k: 0, ix: 10 },
                                p: { a: 0, k: [0, 0, 0], ix: 2 },
                                a: { a: 0, k: [0, 0, 0], ix: 1 },
                                s: { a: 0, k: [100, 100, 100], ix: 6 }
                            },
                            ao: 0,
                            shapes: [
                                {
                                    ty: "gr",
                                    it: [
                                        {
                                            ind: 0,
                                            ty: "sh",
                                            ix: 1,
                                            ks: {
                                                a: 0,
                                                k: bezierPath,
                                                ix: 2
                                            },
                                            nm: "Path 1",
                                            mn: "ADBE Vector Shape - Group",
                                            hd: false
                                        },
                                        {
                                            ty: "fl",
                                            c: {
                                                a: 0,
                                                k: [rgb.r / 255, rgb.g / 255, rgb.b / 255, 1],
                                                ix: 4
                                            },
                                            o: { a: 0, k: 100, ix: 5 },
                                            r: 1,
                                            bm: 0,
                                            nm: "Fill 1",
                                            mn: "ADBE Vector Graphic - Fill",
                                            hd: false
                                        },
                                        {
                                            ty: "tr",
                                            p: { a: 0, k: [0, 0], ix: 2 },
                                            a: { a: 0, k: [0, 0], ix: 1 },
                                            s: { a: 0, k: [100, 100], ix: 3 },
                                            r: { a: 0, k: 0, ix: 6 },
                                            o: { a: 0, k: 100, ix: 7 },
                                            sk: { a: 0, k: 0, ix: 4 },
                                            sa: { a: 0, k: 0, ix: 5 },
                                            nm: "Transform"
                                        }
                                    ],
                                    nm: "Shape 1",
                                    np: 3,
                                    cix: 2,
                                    bm: 0,
                                    ix: 1,
                                    mn: "ADBE Vector Group",
                                    hd: false
                                }
                            ],
                            ip: appearFrame,
                            op: overallEndFrame + 30,
                            st: 0,
                            bm: 0
                        };
                        
                        lottieJSON.layers.push(layer);
                        layerIndex++;
                    }
                } else {
                    // Use segments for uniform width strokes
                    const segmentSize = 30;
                    const stepSize = 25;
                
                for (let i = 0; i < strokePoints.length - 1; i += stepSize) {
                    const endIdx = Math.min(i + segmentSize, strokePoints.length);
                    const segmentPoints = strokePoints.slice(i, endIdx);
                    
                    if (segmentPoints.length < 2) continue;
                    
                    // Average pressure for this segment
                    const avgPressure = segmentPoints.reduce((sum, p) => sum + p.pressure, 0) / segmentPoints.length;
                    const segmentWidth = stroke.baseWidth * avgPressure;
                    
                    // Create smooth bezier path for segment
                    const bezierPath = createSmoothBezierPath(segmentPoints);
                    
                    const startTime = segmentPoints[0].time;
                    const endTime = segmentPoints[segmentPoints.length - 1].time;
                    
                    // GLOBAL EASING: Apply easing to WHEN this segment appears/animates
                    // Linear progress for start and end of this segment
                    const linearStartProgress = (startTime - drawingStartTime) / totalDrawingDuration;
                    const linearEndProgress = (endTime - drawingStartTime) / totalDrawingDuration;
                    
                    // Apply easing function to get EASED times
                    const easedStartProgress = applyEasingToProgress(linearStartProgress, easingType);
                    const easedEndProgress = applyEasingToProgress(linearEndProgress, easingType);
                    
                    // Convert to frame numbers
                    const globalStartFrame = Math.round(easedStartProgress * overallEndFrame);
                    const globalEndFrame = Math.round(easedEndProgress * overallEndFrame);
                    
                    // Line cap
                    let lineCap = 2; // round
                    if (stroke.brushType === 'marker' || stroke.brushType === 'pencil' || stroke.brushType === 'calligraphy') {
                        lineCap = 2;
                    }
                    
                    // Opacity
                    let opacity = 100;
                    if (stroke.brushType === 'marker') {
                        opacity = 60;
                    } else if (stroke.brushType === 'pencil') {
                        opacity = 70;
                    }
                    
                    const layer = {
                        ddd: 0,
                        ind: layerIndex + 1,
                        ty: 4,
                        nm: `Stroke ${strokeIdx + 1} Seg ${Math.floor(i / stepSize)}`,
                        sr: 1,
                        ks: {
                            o: { a: 0, k: opacity, ix: 11 },
                            r: { a: 0, k: 0, ix: 10 },
                            p: { a: 0, k: [0, 0, 0], ix: 2 },
                            a: { a: 0, k: [0, 0, 0], ix: 1 },
                            s: { a: 0, k: [100, 100, 100], ix: 6 }
                        },
                        ao: 0,
                        shapes: [
                            {
                                ty: "gr",
                                it: [
                                    {
                                        ind: 0,
                                        ty: "sh",
                                        ix: 1,
                                        ks: {
                                            a: 0,
                                            k: bezierPath,
                                            ix: 2
                                        },
                                        nm: "Path 1",
                                        mn: "ADBE Vector Shape - Group",
                                        hd: false
                                    },
                                    {
                                        ty: "st",
                                        c: {
                                            a: 0,
                                            k: [rgb.r / 255, rgb.g / 255, rgb.b / 255, 1],
                                            ix: 3
                                        },
                                        o: { a: 0, k: 100, ix: 4 },
                                        w: { a: 0, k: segmentWidth, ix: 5 },
                                        lc: lineCap,
                                        lj: 2,
                                        bm: 0,
                                        nm: "Stroke 1",
                                        mn: "ADBE Vector Graphic - Stroke",
                                        hd: false
                                    },
                                    {
                                        ty: "tm",
                                        s: { a: 0, k: 0, ix: 1 },
                                        e: {
                                            a: 1,
                                            k: [
                                                { i: { x: [0.5], y: [1] }, o: { x: [0.5], y: [0] }, t: globalStartFrame, s: [0] },
                                                { t: globalEndFrame, s: [100] }
                                            ],
                                            ix: 2
                                        },
                                        o: { a: 0, k: 0, ix: 3 },
                                        m: 1,
                                        ix: 3,
                                        nm: "Trim Paths 1",
                                        mn: "ADBE Vector Filter - Trim",
                                        hd: false
                                    },
                                    {
                                        ty: "tr",
                                        p: { a: 0, k: [0, 0], ix: 2 },
                                        a: { a: 0, k: [0, 0], ix: 1 },
                                        s: { a: 0, k: [100, 100], ix: 3 },
                                        r: { a: 0, k: 0, ix: 6 },
                                        o: { a: 0, k: 100, ix: 7 },
                                        sk: { a: 0, k: 0, ix: 4 },
                                        sa: { a: 0, k: 0, ix: 5 },
                                        nm: "Transform"
                                    }
                                ],
                                nm: "Shape 1",
                                np: 3,
                                cix: 2,
                                bm: 0,
                                ix: 1,
                                mn: "ADBE Vector Group",
                                hd: false
                            }
                        ],
                        ip: 0,
                        op: overallEndFrame + 30,
                        st: 0,
                        bm: 0
                    };
                
                    lottieJSON.layers.push(layer);
                    layerIndex++;
                }
                } // end else (uniform width strokes)
            });
            
            console.log(`Generated ${lottieJSON.layers.length} layers for ${strokes.length} strokes`);
            if (lottieJSON.layers.length > 30) {
                console.warn(` ${lottieJSON.layers.length} layers detected. For smoother performance:`);
                console.warn(`    Increase smoothing to 70-80%`);
                console.warn(`    Use shorter, simpler strokes`);
                console.warn(`    Draw with less pressure variation if not needed`);
            }
            
            return lottieJSON;
        }
        
        // Exact conversion of canvas quadratic curves to Lottie cubic bezier
        function createSmoothBezierPath(points) {
            if (points.length < 2) {
                return {
                    i: [[0, 0]],
                    o: [[0, 0]],
                    v: [[points[0].x, points[0].y]],
                    c: false
                };
            }
            
            if (points.length === 2) {
                // Straight line with slight curve for smoothness
                const dx = (points[1].x - points[0].x) / 3;
                const dy = (points[1].y - points[0].y) / 3;
                return {
                    i: [[0, 0], [-dx, -dy]],
                    o: [[dx, dy], [0, 0]],
                    v: [[points[0].x, points[0].y], [points[1].x, points[1].y]],
                    c: false
                };
            }
            
            if (points.length === 3) {
                // Simple quadratic curve
                const p0 = points[0];
                const p1 = points[1];
                const p2 = points[2];
                
                const cp1 = {
                    x: p0.x + (2/3) * (p1.x - p0.x),
                    y: p0.y + (2/3) * (p1.y - p0.y)
                };
                const cp2 = {
                    x: p2.x + (2/3) * (p1.x - p2.x),
                    y: p2.y + (2/3) * (p1.y - p2.y)
                };
                
                return {
                    i: [[0, 0], [cp2.x - p2.x, cp2.y - p2.y]],
                    o: [[cp1.x - p0.x, cp1.y - p0.y], [0, 0]],
                    v: [[p0.x, p0.y], [p2.x, p2.y]],
                    c: false
                };
            }
            
            const vertices = [];
            const inTangents = [];
            const outTangents = [];
            
            // First point
            vertices.push([points[0].x, points[0].y]);
            inTangents.push([0, 0]);
            
            // First out tangent
            const firstCP1 = {
                x: points[0].x + (2/3) * (points[1].x - points[0].x),
                y: points[0].y + (2/3) * (points[1].y - points[0].y)
            };
            outTangents.push([
                firstCP1.x - points[0].x,
                firstCP1.y - points[0].y
            ]);
            
            // Middle vertices at midpoints
            for (let i = 1; i < points.length - 1; i++) {
                const p0 = points[i - 1];
                const p1 = points[i];
                const p2 = points[i + 1];
                
                const midEnd = {x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2};
                vertices.push([midEnd.x, midEnd.y]);
                
                const cp2 = {
                    x: midEnd.x + (2/3) * (p1.x - midEnd.x),
                    y: midEnd.y + (2/3) * (p1.y - midEnd.y)
                };
                inTangents.push([
                    cp2.x - midEnd.x,
                    cp2.y - midEnd.y
                ]);
                
                if (i < points.length - 2) {
                    const nextControl = points[i + 1];
                    const cp1Next = {
                        x: midEnd.x + (2/3) * (nextControl.x - midEnd.x),
                        y: midEnd.y + (2/3) * (nextControl.y - midEnd.y)
                    };
                    outTangents.push([
                        cp1Next.x - midEnd.x,
                        cp1Next.y - midEnd.y
                    ]);
                } else {
                    outTangents.push([0, 0]);
                }
            }
            
            // Last point
            const last = points[points.length - 1];
            vertices.push([last.x, last.y]);
            
            const secondLast = points[points.length - 2];
            const lastCP2 = {
                x: last.x + (2/3) * (secondLast.x - last.x),
                y: last.y + (2/3) * (secondLast.y - last.y)
            };
            inTangents.push([
                lastCP2.x - last.x,
                lastCP2.y - last.y
            ]);
            outTangents.push([0, 0]);
            
            return {
                i: inTangents,
                o: outTangents,
                v: vertices,
                c: false
            };
        }
        
        // Smooth path using quadratic interpolation (legacy, not used anymore)
        function smoothPath(points) {
            if (points.length < 3) {
                return points.map(p => [p.x, p.y]);
            }
            
            const smoothed = [];
            
            for (let i = 0; i < points.length - 2; i++) {
                const p0 = points[i];
                const p1 = points[i + 1];
                const p2 = points[i + 2];
                
                // Add midpoint
                smoothed.push([p0.x, p0.y]);
                
                // Add curved point using quadratic interpolation
                const midX = (p0.x + p1.x * 2 + p2.x) / 4;
                const midY = (p0.y + p1.y * 2 + p2.y) / 4;
                smoothed.push([midX, midY]);
            }
            
            // Add last two points
            smoothed.push([points[points.length - 2].x, points[points.length - 2].y]);
            smoothed.push([points[points.length - 1].x, points[points.length - 1].y]);
            
            return smoothed;
        }
        
        function downloadLottie(lottieData) {
            const jsonString = JSON.stringify(lottieData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `drawing-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function showPreview(lottieData) {
            previewArea.innerHTML = '<div id="lottiePreview" style="width: 100%; max-width: 800px;"></div>';
            
            if (lottieInstance) {
                lottieInstance.destroy();
            }
            
            const loopType = loopTypeInput.value;
            let loopSetting = true;
            
            if (loopType === 'once') {
                loopSetting = false;
            } else if (loopType === 'pingpong') {
                loopSetting = false; // We'll handle ping pong manually
            }
            
            lottieInstance = lottie.loadAnimation({
                container: document.getElementById('lottiePreview'),
                renderer: 'svg',
                loop: loopSetting,
                autoplay: true,
                animationData: lottieData
            });
            
            // Handle reverse loop
            if (loopType === 'reverse') {
                lottieInstance.setDirection(-1);
            }
            
            // Handle ping pong: play forward, then backward, repeat
            if (loopType === 'pingpong') {
                lottieInstance.setDirection(1); // Start forward
                
                lottieInstance.addEventListener('complete', function() {
                    // Flip direction and play again
                    lottieInstance.setDirection(lottieInstance.playDirection * -1);
                    lottieInstance.play();
                });
            }
        }
        
        function showStatus(message) {
            status.textContent = message;
            status.classList.add('active');
            setTimeout(() => {
                status.classList.remove('active');
            }, 3000);
        }
    </script>
</body>
</html>
